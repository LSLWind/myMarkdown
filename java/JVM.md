## JAVA内存管理

### JAVA运行时内存区域

* 程序计数器：线程私有，记录字节码指令地址
* 栈：线程私有，描述方法执行的内存模型，存放栈帧，包括局部变量表，方法出口等信息
* 堆：线程共享，存放对象实例与数组
* 方法区：线程共享，存放类信息，静态变量，常量池等
* 运行时常量池：方法区的一部分，存储编译器生成的class符号引用等

### 对象创建过程

遇到new 时先去常量池查找类符号引用，判断类是否被加载，未被加载则先执行类加载过程，之后为对象分配空间（内存大小可在类加载完成后完全确定），将内存空间初始化为0，对对象头设置必要的信息数据。

### 对象内存布局

**对象头**：包括运行时数据(Mark World)，如哈希码，偏向线程id，锁状态标志等；类型指针（指向.class的指针），虚拟机通过该指针确定对象是哪个类的实例。另外，如果对象是java数组，则对象头中还包括一块用于记录数组长度的数据（用于确定对象内存大小，数组无法通过元数据获取自身长度）

**实例数据**：代码中定义的字段内容，包括从父类中继承的与在子类中定义的

**对齐填充**：占位符，保证对象内存大小为8的整数倍

### 对象访问定义

对象是引用refernce类型，java程序需要通过栈上的refrence数据来操作堆上的具体对象，如何通过引用去访问对象由具体的虚拟机去实现，主流虚拟机有两种实现方式

**使用句柄访问**：在java堆中划分出一块内存作为句柄池，refrence中存储对象的句柄地址，句柄地址则包含指向对象实例数据（实际对象，堆中）与类型数据的地址（类，方法区中）这两部分信息

**直接指针访问**：refrence直接存储对象地址，对象中则必须包含能够访问类型数据的地址

## GC与内存分配

PC、栈等都是线程私有，栈帧中的内存在类结构确定下来时就是已知的，而堆与方法区则不同，程序只有在运行时才知道会创建那些对象，内存分配与回收都是动态的

### 确定对象是否存活

一般使用**可达性分析算法**来确定对象是否存活（也就是对象是否需要被回收），基本思想是：使用一系列的称为“GC Roots"的对象作为起始点，从该起始点向下搜索，走过的路径称为引用链，当从GC Root到某个对象不可达时（没有任何引用链）则判定该对象已死

[<img src="https://s2.ax1x.com/2020/02/13/1L0Sqs.png" alt="1L0Sqs.png" style="zoom:50%;" />](https://imgchr.com/i/1L0Sqs)

一般的引用指的是该引用类型中存储的数据是另一块内存的起始地址，java对引用类型进行了扩充，有四种类型：

* 强引用：普遍存在的，如Object o=new Object()，只要强引用还在则永远不被GC
* 软引用：描述还有用但并非必须的对象，在内存将要溢出之前进行回收，使用类SortReference来实现
* 弱引用：同样描述非必须对象，GC时回收该部分，由类WeakReference来实现
* 虚饮用：最弱的引用关系，无法通过虚引用来取得对象实例，唯一的目的就是该对象被GC时收到一个系统通知

### 垃圾收集算法

**标记-清除算法**：首先标记出所有需要回收的对象，在标记完成后进行统一回收，其缺点主要有两个：效率过低，标记与清除的过程的效率都不高；空间问题，会导致出现过多的内部碎片

**复制算法**：将内存分为容量相等的两块，每次只使用其中的一块，当这块用完时就将这块还存活的对象复制到另一块上面去，然后将这半块进行统一回收，缺点就是将内存分为了原来的一半，代价过大

现代虚拟机则并不会将内存等分，而是（新生代）分为一块较大的Eden空间和两块较小的Survivor空间（比例为8:1），每次使用Eden与一块Survivor，当回收时，将Eden与Survivor中还存活的对象分配到另一块Survivor中，如果这块Survivor内存不够，则这些对象通过分配担保机制进入老年代

**标记-整理算法**：同标记-清除算法，但标记完不是直接清除，而是让存活对象向一侧移动，清除掉端边界以外的内存即可

**分代收集算法**：现代虚拟机常用，根据对象存活周期将内存划分为几块，一般分为新生代与老年代，新生代对象经常死去，采用复制算法；老年代采用标记-清除或标记-整理算法

GC时系统必须停顿，保证系统引用关系没有动态变化，当GC时系统能够准确知道引用位置，HotSpot中使用一组名为OopMap的数据结构保存类加载时对象的引用位置，这样GC时就可以直接获得引用位置，完成GC Roots的枚举。

每一条指令执行完毕后，系统的引用关系都有可能发生变化，因此理论上来讲每条指令执行完毕后都会产生不同的OopMap，HotSpot中定义了一系列**安全点（Safepoint）**，只在安全点记录信息，因此程序只能在到达安全点时才能开始进行GC，对于多线程来说，采用**主动式中断思想**：系统需要GC时设置一个标志，各个线程在执行时主动去轮询该标志，当发现中断标志位是该线程就自己中断。同时系统会规划一整段**安全区（Safe Region)**,只要线程要进入安全区时就标记自己在安全区，因此GC时系统就不用检查该线程，当该线程离开安全区时则要检查系统是否已经完成了根节点枚举，如果没有则必须等待。

### 垃圾收集器

垃圾收集器是垃圾回收算法理论的实现，主要几款收集器为

**Serial收集器**：新生代、单线程收集器，使用GC线程去GC，停止系统所有工作线程（Stop The World），因此每隔一段时间系统就会停止一段时间去GC，使用复制算法

**ParNew收集器**：Serial收集器的多线程版本、新生代收集器，使用复制算法

**Parallel Scavenge收集器**：新生代、多线程收集器，使用复制算法，与ParNew的区别在于其追求吞吐量（吞吐量=运行用户代码时间/（运行用户代码时间+GC时间）），停顿越短代表响应速度越快，吞吐量越大代表CPU利用率越高

**Serial Old 收集器**：Serial收集器的老年代版本、单线程，使用标记-整理算法

**Parallel Old 收集器**：Parallel Scavenge收集器的老年代版本、多线程，使用标记-整理算法

**CMS 收集器**：老年代、多线程，使用标记-清除算法，整个过程分为四步：初始标记（需停顿，仅对GC Roots能直接关联到的对象进行标记）→并发标记（执行可达性分析，找到GC Roots引用链）→重新标记（需停顿，修正因并发标记期间系统运作导致的对象变动）→并发清除

**G1 收集器**：较新的老年代收集器、可并发、多线程，用于取代CMS，将整块的新生代与老年代划分为不连续的多个Region的集合进行收集，回收过程与CMS差不多，步骤为：初始标记→并发标记→最终标记→筛选回收

### 对象内存分配

**对象优先分配在Eden区**，也就是新生对象优先分配在新生代，当Eden区没有足够的空间时将进行一次MinorGC（Minor GC指新生代GC，对应的，Full GC指老年代GC），**大对象直接进入老年代**（大对象指需要大量连续内存空间的java对象），目的是避免在Eden与Survivor之间的来回大对象复制（Eden与Survivor共同组成新生代内存，复制算法回收新生代内存），**长期存活对象进入老年代**，虚拟机对每个对象定义了一个对象Age计数器，如果对象在Eden出生并经过一次Minor GC则移入Survivor空间，将Age置为1，每经过一次Minor GC则Age加一，当Age达到阈值（默认15）则进入老年代，同时执行动态年龄判定，如果Survivor空间中相同年龄的所有对象大小总和大于Survivor的一般则这些对象可直接进入老年代。

在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。

新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。

取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。

## OOM异常

### java堆溢出

java堆用于存储对象实例，只要不断创建对象并保证GC Roots到对象之间没有可达路径以避免垃圾回收，当对象数量到达最大堆容量后就会产生java堆溢出

```java
public class HeapOOM{
	static class OOMObject{
	}
	public static void main(String[] args){
	    List<OOMObject>list=new ArrayList<OOMObject>();
	    while(true){
	        list.add(new OOMObject());
	    }
	}
}
```

解决思路：

* 可能是内存泄漏， 内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存，内存泄漏是由于某些内存未被自动回收导致的，此时应该借助工具查看确定泄漏对象以及GC Roots引用链信息，定位泄漏位置
* 如果是真的java堆溢出则应该调整JVM堆的最大参数，或者检查代码，分析内存布局，减少对象内存 

### 虚拟机栈/本地方法栈溢出

线程请求的栈深度大于虚拟机允许的最大深度则抛出StackOverflowError(如方法无限递归)；如果虚拟机栈扩展时无法申请到足够的空间则抛出OutOfMemoryError

栈溢出经常碰到

```java
public class JacaVMStackSOF{
	private int stackLength=1;
	public void stackLeak(){
		stackLength++;
		stackLeak();
	}
	public static void main(String[] args){
		JacaVMStackSOF oom=new JacaVMStackSOF();
		try{
			oom.stackLeak();
		}catch(Throwable e){
			e.printStackTrace();
            throw e;
		}
	}
}
```

建立过多的线程同样可能造成栈溢出，每个线程分配的栈大小与栈容量参数有关，进程内存=堆+方法区+栈*线程数，如果是过多线程导致的栈溢出可以减少线程数量或者减少栈容量来换取更多的线程

## 类文件结构

Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是何种语言