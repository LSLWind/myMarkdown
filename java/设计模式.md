[TOC]

### UML

##### 关联关系(Association)

是类与类之间最常用的一种关系， 它是一种结构化关系，用于表示一类对象与另一类对象之间有联系。 

单线实箭头，可自关联

![](https://pic.superbed.cn/item/5dc400758e0e2e3ee95d8592.jpg)

关联关系中要表明对象间的关联关系，如是一对多还是一对一

![](https://pic.superbed.cn/item/5dc400d48e0e2e3ee95daa53.jpg)

##### 依赖关系(Dependency)

一种使用关系，例如类A的某个方法需要类B做参数，即要使用类B的方法，用虚线表示

![](https://pic.superbed.cn/item/5dc4027c8e0e2e3ee95e8da3.jpg)

##### 聚合关系(Aggregation)

表示一个整体与部分的关系，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立 存在。聚合关系用带空心菱形的直线表示。

![](https://pic.superbed.cn/item/5dc401468e0e2e3ee95e2453.jpg)

##### 组合关系(Composition)

也表示类之间整体和部分的关系， 但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之间具有同生共死的关系。 如必须传递某个构造器参数以初始化类，用实心菱形的直线表示。

![](https://ae01.alicdn.com/kf/Hc013f39ab3b84ba09594e62351ceef45F.jpg)

##### 泛化关系(Generalization)

就是继承关系，用带空心三角形的直线来表示。 

##### 实现关系(Realization)

接口与实现的关系，用带空心三角形的虚线来表示。 

## 设计模式

### 面向对象设计原则

[![QnGkdA.md.png](https://s2.ax1x.com/2019/12/02/QnGkdA.md.png)](https://imgse.com/i/QnGkdA)

**单一职责原则** :一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。类的职责主要包括两个方面：数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。 单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。 

<img src="https://s2.ax1x.com/2019/12/15/Qfx8KS.png" alt="Qfx8KS.png" style="zoom:67%;" />

[<img src="https://s2.ax1x.com/2019/12/15/QfxQ8P.md.png" alt="QfxQ8P.md.png" style="zoom:67%;" />](https://imgse.com/i/QfxQ8P)

**开闭原则：**抽象化是开闭原则的关键。开闭原则还可以通过一个更加具体的“对可变性封 装原则”来描述，对可变性封装原则(Principle of Encapsulation of Variation, EVP)要求找到系统的可变因素并将其封装起来。

  [<img src="https://s2.ax1x.com/2019/12/15/QfxVDe.md.png" alt="QfxVDe.md.png" style="zoom:67%;" />](https://imgse.com/i/QfxVDe)

[<img src="https://s2.ax1x.com/2019/12/15/QfxpNR.md.png" alt="QfxpNR.md.png" style="zoom:67%;" />](https://imgse.com/i/QfxpNR)

**里氏代换原则： **里氏代换原则可以通俗表述为：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话， 那么它不一定能够使用基类。 里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 

[<img src="https://s2.ax1x.com/2019/12/15/Qfv57j.md.png" alt="Qfv57j.md.png" style="zoom:67%;" />](https://imgse.com/i/Qfv57j)

<img src="C:\Users\lsl\AppData\Roaming\Typora\typora-user-images\1576416279276.png" alt="1576416279276" style="zoom:67%;" />

**依赖倒转原则：**简单来说，依赖倒转原则就是指：代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程， 而不是针对具体类编程。 实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话， 那么依赖倒转原则就是面向对象设计的主要手段。

[<img src="https://s2.ax1x.com/2019/12/15/QfvdXD.md.png" alt="QfvdXD.md.png" style="zoom:67%;" />](https://imgse.com/i/QfvdXD)



[<img src="https://s2.ax1x.com/2019/12/15/QfvU1K.md.png" alt="QfvU1K.md.png" style="zoom:67%;" />](https://imgse.com/i/QfvU1K)

  **接口隔离原则：  **接口隔离原则是指使用多个专门的接口，而不使用单一的总接口。每一个接口应该承担一种相对独立的角色，不多不少，不干不该干的事，该干的事都要干。 (1) 一个接口就只代表一个角色，每个角色都有它特定的一个接口，此时这个原则可以叫做“角色隔离原则”。 (2) 接口仅仅提供客户端需要的行为，即所需的方法，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独 的接口，而不要提供大的总接口。  

[<img src="https://s2.ax1x.com/2019/12/15/Qfvef0.md.png" alt="Qfvef0.md.png" style="zoom:67%;" />](https://imgse.com/i/Qfvef0)

[<img src="https://s2.ax1x.com/2019/12/15/QfvMXF.md.png" alt="QfvMXF.md.png" style="zoom:67%;" />](https://imgse.com/i/QfvMXF)

 **合成复用原则：  **合成复用原则就是指在一个新的对象里通过关联关系 （包括组合关系和聚合关系）来使用一些已有的对象， 使之成为新对象的一部分；新对象通过委派调用已有 对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。 

[<img src="https://s2.ax1x.com/2019/12/15/QfvFmQ.md.png" alt="QfvFmQ.md.png" style="zoom:67%;" />](https://imgse.com/i/QfvFmQ)

[<img src="https://s2.ax1x.com/2019/12/15/QfvATs.md.png" alt="QfvATs.md.png" style="zoom:67%;" />](https://imgse.com/i/QfvATs)

 **迪米特法则： **在狭义的迪米特法则中， 如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 狭义的迪米特法则可以降低类之间的耦合，但是会在系统中增加大量的小方法并散落在系统的各个角落，它可以使一个系统的局部设计简化， 因为每一个局部都不会和远距离的对象有直接的关联，但是也会造成系统的不同模块之间的通信效率降低，使得系统的不同模块之间不容易协 调。广义的迪米特法则：指对对象之间的信息流量、流向以及信息的影响的 控制，主要是对信息隐藏的控制。信息的隐藏可以使各个子系统之间脱 耦，从而允许它们独立地被开发、优化、使用和修改，同时可以促进软件的复用，由于每一个模块都不依赖于其他模块而存在，因此每一个模 块都可以独立地在其他的地方使用。一个系统的规模越大，信息的隐藏就越重要，而信息隐藏的重要性也就越明显。 

[<img src="https://s2.ax1x.com/2019/12/15/QfjXTA.md.png" alt="QfjXTA.md.png" style="zoom: 67%;" />](https://imgse.com/i/QfjXTA)

[<img src="https://s2.ax1x.com/2019/12/15/QfjxYt.md.png" alt="QfjxYt.md.png" style="zoom:67%;" />](https://imgse.com/i/QfjxYt)

### 对象创建型模式

#### 工厂方法模式

产品对象通过公共接口实现功能，抽象工厂声明工厂方法由具体子类去实现，工厂的目的是为了返回产品，抽象工厂声明的方法要返回抽象产品，每一个具体产品都对应有一个具体工厂，具体工厂返回具体产品，利用多态的性质，全程使用接口对象声明即可。

模式结构 

• Product：抽象产品，产品对象的共同父类或接口

• ConcreteProduct：具体产品 ，实现了抽象产品接口

• Factory：抽象工厂，声明工厂方法，交给子类实现

• ConcreteFactory：具体工厂，实现抽象工厂中的工厂方法，返回一个具体产品类的实例

![image.png](https://ae01.alicdn.com/kf/Hbc20c40da15d496a9de7fcbe495783d0K.jpg)

利用多态的性质，将通用方法抽象出来放在接口中，调用时更加灵活

所有的具体工厂类都具有同一抽象父类。在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 

![](https://ae01.alicdn.com/kf/H2b83dff1f9c44debb29bf8f34201abd0e.jpg)

```java
public interface Log {
    void writeLog();
}
public class FileLog implements Log {
    @Override
    public void writeLog(){
        System.out.println("我是文件日志写入器");
    }
}
public class DataBaseLog implements Log {
    @Override
    public void writeLog(){
        System.out.println("我是数据库日志写入器");
    }
}
```

```java
public interface AbstractLogFactory {
    Log createLog();
}
public class FileLogFactory implements AbstractLogFactory{
    @Override
    public Log createLog(){
        return new FileLog();
    }
}
public class DataBaseLogFactory implements AbstractLogFactory {
    @Override
    public Log createLog(){
        return new DataBaseLog();
    }
}
```

```java
public class FactoryMethodPatternTest {
    public static void main(String[] args){
        AbstractLogFactory abstractLogFactory;

        abstractLogFactory=new FileLogFactory();
        abstractLogFactory.createLog().writeLog();

        abstractLogFactory=new DataBaseLogFactory();
        abstractLogFactory.createLog().writeLog();
    }
}
```

运行结果为：

```
我是文件日志写入器
我是数据库日志写入器
```

#### 抽象工厂模式

弥补工厂方法模式每一种产品都需要新增具体工厂的不足，抽象工厂中声明多种产品工厂方法，能为一个产品家族返回多种属于该家族的具体产品。

当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。

模式结构：

 • AbstractFactory：抽象工厂

 • ConcreteFactory：具体工厂

 • AbstractProduct：抽象产品 

• Product：具体产品 

同样利用多态性质，符合开闭原则

![](https://ae01.alicdn.com/kf/H5b43c33366ae4f4aa56487c0b1b2aee6L.jpg)

```java
public interface Connection {
    boolean connection(String url,int port,String password);
}
public class OracleConnection implements Connection{
    @Override
    public  boolean connection(String url,int port,String password){
        System.out.println("已连接:"+url+port);
        return true;
    }
}
public class MySqlConnection implements Connection{
    @Override
    public  boolean connection(String url,int port,String password){
        System.out.println("已连接:"+url+port);
        return true;
    }
}
```

```java
public interface Statement {
    boolean getStatement();
}
public class OracleStatement implements Statement {
    @Override
    public  boolean getStatement(){
        System.out.println("create Oracle Statement");
        return true;
    }
}
public class MySqlStatement implements Statement {
    public  boolean getStatement(){
        System.out.println("create MySql Statement");
        return true;
    }
}
```

```java
public interface AbstractFactory {
    Connection createConnection();
    Statement createStatement();
}
public class OracleFactory implements AbstractFactory{
    @Override
    public Connection createConnection(){
        return new OracleConnection();
    }
    @Override
    public Statement createStatement(){
        return new OracleStatement();
    }
}
public class MySqlFactory implements AbstractFactory {
    @Override
    public Connection createConnection(){
        return new MySqlConnection();
    }
    @Override
    public Statement createStatement(){
        return new MySqlStatement();
    }
}
```

同样使用多态的性质，如果使用工厂方法模式，那么就需要建造两个抽象工厂，四个具体工厂，因为两个抽象产品属于同一个产品家族，所以只使用一个抽象工厂，把生产工厂的方法放在一起即可。缺点是难以扩展抽象产品，因为必须属于同一产品族的产品才可以加入，为了达到单一职责原则，不能在抽象工厂中任意添加产品

#### 建造者模式

将部件和其组装过程分开，一步一步创建一个复杂的对象。即将一个复杂对象的构建与它的表示分离。

也可能存在多个基本部分对象，基本部分对象通过不同的组合可以构建不同的对象，用户使用不同的具体建造者即可得到不同的产品对象。

模式结构

• Director：指挥者 ，用于实际生产产品，内部有方法construct，规定一个产品的构造顺序（即如何构造），通过对基本对象的组合生成一个复杂产品，内部维护建造者Builder，通过construct按顺序建造产品

 • Builder：抽象建造者 ，规定建造所有基本对象的方法

• ConcreteBuilder：具体建造者，实现每部分的建造方法

 • Product：产品角色 

建造者模式的目的仍然是为了解耦，屏蔽某些复杂产品的实现，生成产品的组件由接口声明，由具体的建造者建造，由Director调用组件组合顺序生成产品，允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节。

```java
//产品及组件
public class Product {
    private ComponentA componentA;
    private ComponentB componentB;
    public Product(ComponentA componentA,ComponentB componentB){
        this.componentA=componentA;
        this.componentB=componentB;
    }
    @Override
    public String toString(){
        return "我是产品";
    }
}

public class ComponentA {
    @Override
    public String toString(){
        return "我是组件A";
    }
}

public class ComponentB {
    @Override
    public String toString(){
        return "我是组件B";
    }
}
```

```java
//建造者及实现
public interface Builder {
    ComponentA buildA();
    ComponentB buildB();
}
public class ConcreteBuilder implements Builder{
    @Override
    public ComponentA buildA(){
        System.out.println("创建组件A");
        return new ComponentA();
    }
    @Override
    public ComponentB buildB(){
        System.out.println("创建组件B");
        return new ComponentB();
    }
}
```

```java
//指挥者，规定产品组合顺序，调用建造者组装成产品并返回
public class Director {
    public static Product buildProduct(){
        Builder builder=new ConcreteBuilder();
        return new Product(builder.buildA(),builder.buildB());
    }
}
public class builderPatternTest {
    public static void main(String[] args){
        Product product=Director.buildProduct();
        System.out.println(product.toString());
    }
}
/*运行结果
创建组件A
创建组件B
我是产品
*/
```

#### 原型模式

对象创建型模式，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象

在原型模式结构中定义了一个抽象原型类，所有的Java类都继承 自java.lang.Object，而Object类提供一个clone()方法，可以将 一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。 能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了 clone()方法，Java编译器将抛出一个 CloneNotSupportedException异常。

浅克隆只克隆同一份对象的域的引用，深克隆开辟新的空间并赋值

java中的clone()是深克隆，但copy的内存中如果有引用变量，那么引用的仍然是同一块空间，如果想让引用变量引用的空间也克隆一份，那么最好重写clone()或者自己另写一个创建原型的方法

```java
import java.util.Properties;
public class PrototypePatternTest {
    public static void main(String[] args){
        Properties properties=new Properties();
        properties.put("a",new Properties());
        Properties propertiesClone=(Properties) properties.clone();

        System.out.println(properties==propertiesClone);
        System.out.println(properties.getClass()==propertiesClone.getClass());
        
        //clone的对象引用新的空间
        properties.put("b",2);
        System.out.println(propertiesClone.get("b"));
        
        //但是内部的引用变量仍然引用同一块空间
        ((Properties)properties.get("a")).put("b","2");
        System.out.println(((Properties)propertiesClone.get("a")).get("b"));
    }
}
/*结果为
false
true
null
2
*/
```

使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。 

#### 单例模式

单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

单例模式的要点有三个：一是某个类只能有一个实例； 二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。

模式结构 

• Singleton：单例 

单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。

* 单例类的构造函数为私有； 
*  提供一个自身的静态私有成员变量； 
*  提供一个公有的静态工厂方法。  

确保只有一个对象被实例化的关键在于将构造器私有化，这样外部无法使用new构建对象，也无法通过反射实例化对象，这样一种设计思想确保系统中只有一个实例，提供关键服务，但对于该实例来说内部封装的对象的操作在并发环境下仍要保持原子性，单例模式确保我只有我一个，最常用的便是提供序列化id，系统必须确保每次提供的是唯一id，因此采用单例模式+原子操作（静态方法+原子操作也可以）。

```java
public class Singleton {

    private static Singleton singleton=new Singleton();

    private static volatile long id;
    //单例模式，私有化构造器，避免其他类new该对象
    private Singleton(){

    }
    public static Singleton getSingleton() {
        return singleton;
    }

    public synchronized long getId(){
        return id++;
    }
}
```

```java
public class SingletonPatternTest {
    public static void main(String[] args){
        //错误，不能访问私有
        //Singleton singleton=new Singleton();
        /*通过反射实例化将抛出java.lang.IllegalAccessException异常
        try {
            Singleton singleton=Singleton.class.newInstance();
        }catch (Exception e){
            e.printStackTrace();
        }
        */
        Singleton singleton=Singleton.getSingleton();
        for(int i=0;i<10;i++){
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName()+"我的id:"+singleton.getId());
                }
            }).start();
        }

    }
}
```

### 对象结构型模式

结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构

#### 适配器模式

在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者 (Adaptee)，即被适配的类。适配器提供客户类需要的接口，适配器的实现就是把客户类的请求 转化为对适配者的相应接口的调用。适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。 

简单的说，需要实现一个接口，这个接口的功能已经有一个类实现，但这个类却不符合接口的规则，因此使用适配器Adapter包装适配者Adaptee（可以有多个Adaptee），调用Adaptee的方法进行二次封装到Adapter的方法中，使用者调用Adapter的方法，并不关心适配器如何实现，反正Adapter对外能够提供功能即可

**模式定义 ：适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。** 

**适配器的核心在于使用新的类实现旧接口，老接口不能轻易动，新的实现类不符合老接口的规则，因此使用适配器实现老接口，调用新类的方法，相当于对各种实现类进行统合，对外能够通过统一的旧接口提供功能。**

 ![img](https://pic3.zhimg.com/v2-820a6161f73f65043ea3a35901df11ae_b.jpg) 

Outlet提供电压，AC plug插不进去，使用Adapter进行中间转化，使用者可以利用多态使用AC plug返回一个Adapter，Adapter调用Outlet提供电压。

[![M3LtmV.md.png](https://s2.ax1x.com/2019/11/12/M3LtmV.md.png)](https://imgchr.com/i/M3LtmV)

适配器模式有三种实现方式：

 **类适配器**

Adapter继承功能类实现老接口，通过super调用方法

```java
@Configuration
public class SpringConfiguration {
    @Bean
    public Outlet220V outlet220V(){
        return new Outlet220V();
    }

    @Bean(name="adapterA")
    public AdapterA adapterA(){
        return new AdapterA();
    }
}
public interface Outlet5V {
    //提供5V电压
    int outlet5V();
}
//新的实现类，能提供220V电压
public class Outlet220V {
    public int outlet220V(){
        System.out.println("我被适配器调用，我能输出220V电压");
        return 220;
    }
}
//类适配器
public class AdapterA extends Outlet220V implements Outlet5V {
    @Override
    public int outlet5V(){
        System.out.println("我是类适配器，继承实现类，实现老接口");
        return super.outlet220V()/44;
    }
}

public class AdapterPatternTest {
    public static void main(String[] args){
        ApplicationContext context= new AnnotationConfigApplicationContext(SpringConfiguration.class);

        Outlet5V outlet5V=(AdapterA)context.getBean("adapterA",AdapterA.class);
        outlet5V.outlet5V();
    }
}
```

**对象适配器**

内部维护实现对象，调用实现方法实现老接口：

```java
public class AdapterB implements Outlet5V{

    private Outlet220V outlet220V=new Outlet220V();

    public int outlet5V(){
        System.out.println("我是对象适配器，内部维护功能对象，调用实现方法实现老接口");
        return outlet220V.outlet220V()/44;
    }
}
```

**接口适配**

介绍完类适配器和对象适配器，我们再来看看接口适配器，接口适配器相对类适配器和对象适配器而言，接口适配器相对更加灵活，就好比手机适配器中的万能适配器，不管接入的是多少伏的电源，最终都能保证输出电源为5V。

首先，定义一个总的抽象类，并且给予一个默认值（或者直接是接口，目的都是为了定义功能），即提供总的抽象

```java
public abstract class AbstractAdapter {
    public int output(){
        return 220;
    }
}
```

基于该抽象类重写方法，提供不同的功能

```java
public class Outlet110V extends AbstractAdapter {
    @Override
    public int output(){
        return 110;
    }
}
public class Outlet440V extends AbstractAdapter {
    @Override
    public int output(){
        return 440;
    }
}
```

适配器内部维护一个总的抽象对象，提供不同的构造器，提供setter，实现老接口时，必须能判断当前维护的抽象对应的具体实现是哪一个，可使用instanceof或者反射

```java
public class AdapterC implements Outlet5V {
    private AbstractAdapter abstractAdapter;
    public AdapterC(AbstractAdapter abstractAdapter){
        this.abstractAdapter=abstractAdapter;
    }

    //这里是接口适配器，内部维护总的抽象，可以是接口，也可以是抽象类，对外提供方法，因此必须有办法判断
    //具体是哪一个实现，可使用instanceof，也可以使用反射读取信息
    @Override
    public int outlet5V(){
        System.out.println("我是接口适配器，内部维护一个总抽象，根据instanceof判断当前是哪一个实现");
        if(abstractAdapter instanceof  Outlet110V)return abstractAdapter.output()/22;
        else if(abstractAdapter instanceof Outlet440V)return abstractAdapter.output()/88;
        return 5;
    }
}
```

#### 桥接模式

将抽象部分与它的实现部分分离，使它们都可以独立地变化。将抽象化(Abstraction)与实现化 (Implementation)脱耦，使得二者可以独立地变化。

 假设有两个接口A与B，A有6个具体实现，B有4个具体实现，现在必须组合A，B以提供组合式的更强的功能，共有6*4=24个具体提供，为实现解耦，现在将某一个接口抽象化，将A变为抽象类，内部维护一个B并提供setter，A的具体实现都要继承A，因为A内部维护一个B并提供setter，因此A不关心具体的B是哪一个，调用功能即可，只需6+4=10个具体提供。

模式结构 ：

 • Abstraction：抽象类，内部维护一个Implementor并提供setter

 • RefinedAbstraction：扩充抽象类

 • Implementor：实现类接口 

• ConcreteImplementor：具体实现类  

[![McFXVO.md.png](https://s2.ax1x.com/2019/11/18/McFXVO.md.png)](https://imgchr.com/i/McFXVO)

抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。 

• 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

 • 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增 加的系统，桥接模式尤为适用。

```java
//实现接口与具体实现
public interface VideoStream {
    public void videoStream();
}
public class AVIVideoStream implements VideoStream {
    @Override
    public void videoStream(){
        System.out.println("提供AVI视频流");
    }
}
public class MP4VideoStream implements VideoStream {
    @Override
    public void videoStream(){
        System.out.println("提供mp4视频流");
    }
}
```

```java
//抽象类与扩充实现
public abstract class VideoPlay {
    private VideoStream videoStream;
    public VideoPlay(VideoStream stream){
        this.videoStream=stream;
    }
    public VideoStream getVideoStream(){
        return videoStream;
    }

    public void play(){
    }
}
public class Aplay extends VideoPlay {
    public Aplay(VideoStream stream){
        super(stream);
    }
    @Override
    public void play(){
        System.out.println("获取视频流");
        super.getVideoStream().videoStream();
        System.out.println("A play");
    }
}
public class Bplay extends VideoPlay {
    public Bplay(VideoStream videoStream){
        super(videoStream);
    }

    @Override
    public void play(){
        System.out.println("获取视频流");
        super.getVideoStream().videoStream();
        System.out.println("B play");
    }
}
```

```java
public class BridagePatternTest  {
    public static void main(String[] args){
        VideoPlay play=new Aplay(new AVIVideoStream());
        play.play();

        play=new Aplay(new MP4VideoStream());
        play.play();

        play=new Bplay(new AVIVideoStream());
        play.play();

        play=new Bplay(new MP4VideoStream());
        play.play();
    }
}
/*
获取视频流
提供AVI视频流
A play
获取视频流
提供mp4视频流
A play
获取视频流
提供AVI视频流
B play
获取视频流
提供mp4视频流
B play
*/
```

#### 组合模式

组合模式描述了如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象，组合多个对象形成树形结构以表示“整体-部分”的结构层次。

模式结构： 

• Component: 抽象构件

 • Leaf: 叶子构件

 • Composite: 容器构件

 • Client: 客户类 

也就是整体与部分的模式，极其类似于文件与文件夹，文件夹里面可以有子文件夹，也可以有文件，对于这样的抽象树形结构，定义一个抽象构件Component，客户端调用抽象构件，这个抽象构件可以是文件也可以是文件夹，如果是文件（Leaf）直接执行操作，如果是文件夹（Composite）则调用内部维护的抽象构件

Component列表递归遍历。

[![MfOxMV.md.png](https://s2.ax1x.com/2019/11/20/MfOxMV.md.png)](https://imgchr.com/i/MfOxMV)

即定义一个公共抽象类，该公共抽象的子类可以是具体实现，也可以是抽象容器，是容器的话内部就需要维护抽象类的集合列表以供遍历

```java
//公共抽象Component
public abstract class File {
    public abstract void read();
    public abstract void write();

    public abstract void add(File file);
    public abstract void remove(File file);
}
```

```java
//具体实现
public class TextFile extends File {

    @Override
    public void read(){
        System.out.println("读文本文件");
    }
    @Override
    public void write(){
        System.out.println("写文本文件");
    }

    @Override
    public  void add(File file){

    }
    @Override
    public void remove(File file){

    }
}

public class VideoFile extends File{
    @Override
    public void read(){
        System.out.println("读视频文件");
    }
    @Override
    public void write(){
        System.out.println("写视频文件");
    }

    @Override
    public  void add(File file){

    }
    @Override
    public void remove(File file){

    }
}
```

```java
//抽象容器，可继续递归
public class Folder extends File {

    //维护文件列表
    private List<File> fileList=new ArrayList<>();

    @Override
    public void read(){
    }
    @Override
    public void write(){
    }

    @Override
    public  void add(File file){
        fileList.add(file);
    }
    @Override
    public void remove(File file){
        fileList.remove(file);
    }

    public List<File> getFileList(){
        return fileList;
    }
}
```

```java
public class CompositePatternTest {

    public static void main(String[] args){
        Folder folder=new Folder();
        Folder subfolder=new Folder();
        subfolder.add(new TextFile());

        folder.add(new VideoFile());
        folder.add(subfolder);

        dfs(folder);
    }

    public static void dfs(File file){
        if(file instanceof Folder){
            for(File file1:((Folder) file).getFileList()){
                dfs(file1);
            }
        }
        file.read();
    }
}
```

组合模式非常适用于可递归描述的树形数据结构，如目录解析，XML解析

 可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构件也更容易。 定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可以形成复杂的树形结构。缺点就是变得更加抽象，很难对新增构件的类型进行限制。

#### 装饰模式

一般有两种方式可以实现给一个类或对象增加行为： 

• 继承机制，使用继承机制是给现有类添加功能的一种有效途径， 通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。

 • 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)。 

装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。装饰者内部维护原始对象，通过构造方法或者setter进行注入，对原始对象的方法进行重写改造，提供增强后的功能，即成为包装器Wrapper。客户端通过调用装饰器以获得原始对象增强后的功能，Java.io中的BufferInputStream等缓冲流是典型的装饰器模式。

模式结构：

 • Component: 抽象构件

 • ConcreteComponent: 具体构件 

• Decorator: 抽象装饰类 

• ConcreteDecorator: 具体装饰类 

[![MquB5t.md.png](https://s2.ax1x.com/2019/11/23/MquB5t.md.png)](https://imgchr.com/i/MquB5t)

在单一职责原则下，一个类不宜实现过多的功能，一个类能提供其基本功能，但在某些条件下又需要实现一些扩展功能，此时便可以使用继承或者装饰器模式，在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。  装饰器内部维护原始对象，增加逻辑以增加功能。

```java
public interface Cipher {
    String encrypt(String plainText);
}
/**
 * 自由实现，只提供简单加密
 */
public class SimpleCipher implements Cipher {

    @Override
    public String encrypt(String plainText){
        StringBuilder res=new StringBuilder();
        for(char c:plainText.toCharArray()){
            res.append((int) c);
        }
        return res.toString();
    }
}
/**
 * 装饰器，增强功能
 */
public class CipherDecorator implements Cipher {
    private Cipher cipher;
    public CipherDecorator(Cipher cipher){
        this.cipher=cipher;
    }

    public void setCipher(Cipher cipher) {
        this.cipher = cipher;
    }

    @Override
    public String encrypt(String plainText){
        return cipher.encrypt(plainText);
    }

    public String complexEncrypt(String plainText){
        StringBuilder res=new StringBuilder(encrypt(plainText));
        res.reverse();
        return res.toString();
    }

}
```

```java
public class DecoratorPatternTest {
    public static void main(String[] args){
        Cipher cipher=new SimpleCipher();
        System.out.println(cipher.encrypt("HelloWorld"));

        CipherDecorator cipherDecorator=new CipherDecorator(cipher);
        System.out.println(cipherDecorator.complexEncrypt("HelloWorld"));

    }
}
/*结果为
7210110810811187111114108100
0018014111117811180180110127
*/
```

装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。 

 • 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。

 • 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。

 • 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。

装饰模式的缺点 

• 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。

 • 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 

#### 外观模式

外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。又称为门面模式。 

[![MOg9lq.md.png](https://s2.ax1x.com/2019/11/24/MOg9lq.md.png)](https://imgchr.com/i/MOg9lq)

 模式结构： 

• Facade: 外观角色 

• SubSystem:子系统角色 

引入一个外观对象，为子系统提供统一入口，即提供一个统一的访问门面，Facade内部维护子对象，通过方法返回系统，客户端不用显式声明，而是通过该门面进行中间调用

```java
public class Fan {
    public void on(){
        System.out.println("风扇开");
    }
    public void off(){
        System.out.println("风扇关");
    }
}
public class Light {
    public void on(){
        System.out.println("灯开");
    }
    public void off(){
        System.out.println("灯关");
    }
}
public class Facade {
    private Fan fan=new Fan();
    private Light light=new Light();

    public Fan getFan() {
        return fan;
    }

    public Light getLight() {
        return light;
    }
}
```

```java
public class FacadePatternTest {
    public static void main(String[] args){
        Facade facade=new Facade();
        facade.getFan().on();
        facade.getLight().on();
    }
}
/*
风扇开
灯开
*/
```

外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系。

其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。 

#### 享元模式

即Flyweight Pattern，将具有相同性质的某个成员集合称为共享内容，如字母a-z都是字母，组合起来就是一个具有抽象共同特征的集合，外部使用时需要这些细颗粒度的元素组合成一个新的对象（字符串），为避免系统消耗，创建一个享元工厂，内部维护一个享元池，这个享元池就是细颗粒度的集合，当需要字母时通过工厂获取，工厂先判断池中是否有字母，如果存在直接返回就好，如果不存在则创建并返回。

划分颗粒度，将共享内容维护在一个池，外部使用时先判断池中有没有，有则返回，没有则创建并返回，享元模式的目的就是使用共享技术来实现大量细粒度对象的复用，享元工厂与享元池是其核心。 

[![MvooYq.md.png](https://s2.ax1x.com/2019/11/25/MvooYq.md.png)](https://imgchr.com/i/MvooYq)

模式结构：

 • Flyweight: 抽象享元类 ，享元对象（细颗粒度）的接口定义

• ConcreteFlyweight: 具体享元类，享元对象（细颗粒度）的具体实现

 • UnsharedConcreteFlyweight: 非共享具体享元类 ，不使用享元模式时的实现，多次复用细颗粒度状态

• FlyweightFactory: 享元工厂类，内部维护享元池，维护细颗粒度集合

享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能

```java
/**
 * 享元对象的接口定义
 */
public interface NetworkDevice {
    String getType();
}
public class Switch implements NetworkDevice{
    @Override
    public String getType() {
        return "Switch";
    }
}
public class Hub implements NetworkDevice {
    private String type="Hub";
    @Override
    public String getType() {
        return type;
    }
}
public class DeviceFactory {
    private static List<NetworkDevice> deviceList=new ArrayList<>();

    public static NetworkDevice getNetworkDevice(String type){
        for(NetworkDevice networkDevice:deviceList){
            if(networkDevice.getType().equals(type)){
                return networkDevice;
            }
        }
        if(type.equals("Switch"))deviceList.add(new Switch());
        else deviceList.add(new Hub());
        return deviceList.get(deviceList.size()-1);
    }
}
public class FlyweightPattern {
    public static void main(String[] args){
        System.out.println(DeviceFactory.getNetworkDevice("Hub").getType());
        System.out.println(DeviceFactory.getNetworkDevice("Switch").getType());
    }
}
/*
Hub
Switch
*/
```

享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享

享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。

享元模式适用情况包括：一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费； 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中（也就是将大对象进行细粒度分解，使用对象时要按需注入数据）；多次重复使用享元对象。 

#### 代理模式

在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。 

通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机，即给某一个对象提供一个代理，并由代理对象控制对原对象的引用。

代理模式包含如下角色：

 • Subject: 抽象主题角色，可以是抽象类也可以是接口，定义抽象功能

 • Proxy: 代理主题角色 

• RealSubject: 真实主题角色 

静态代理的一般模式为

[![QSdseO.md.png](https://s2.ax1x.com/2019/11/26/QSdseO.md.png)](https://imgchr.com/i/QSdseO)

静态代理就是通过构造一个代理类，内部维护一个代理对象，为该对象的方法提供增强过后的功能，或根据需要设置功能的访问权，静态代理只能是一个具体的类有一个代理角色，功能不强。

```java
public class TestDemo {
    interface IService{
        void say();
    }
    static class A implements IService{
        public void say(){
            System.out.println("I am A");
        }
    }
    static class Proxy implements IService{
        private A a;
        public Proxy(A a){
            this.a=a;
        }

        public void say(){
            System.out.println("我是代理,我先加点东西");
            a.say();
            System.out.println("我是代理，方法调用结束后加点东西");
        }
    }
     
    public static void main(String[] args){
        System.out.println("正常实现A");
        A a=new A();
        a.say();
        System.out.println("代理强化A");
        Proxy aProxy=new Proxy(a);
        aProxy.say();
    }

}
/*
执行结果为:
正常实现A
I am A
代理强化A
我是代理,我先加点东西
I am A
我是代理，方法调用结束后加点东西
*/
```

 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度，保护代理可以控制对真实对象的使用权限，代理模式应用的主要类型有：

 远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地 的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。

  • 虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一 个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 

 • Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个 开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象 被用到的时候才被克隆。 
• 保护(Protect or Access)代理：控制对一个对象的访问，可以给 不同的用户提供不同级别的使用权限。  

• 缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空 间，以便多个客户端可以共享这些结果。 

• 防火墙(Firewall)代理：保护目标不让恶意用户接近。 

 • 同步化(Synchronization)代理：使几个用户能够同时使用一个对 象而没有冲突。 

 • 智能引用(Smart Reference)代理：当一个对象被引用时，提供 一些额外的操作，如将此对象被调用的次数记录下来等。 

**动态代理:**

        说实话，静态代理的功能一点也不强，如果A,B,C...有许多类都需要在方法前加一点东西，不可能为每一个类都写一个对应的代理进行强化，如果能动态生成就好了。有需求必然有变化，java为应对需求推出了类java.lang.reflect.Proxy同时对动态代理设置了一定的规范。
    
          首先，将需要切入的方法抽取出来放在接口中，A照样实现接口从而实现方法。
    
          然后，写一个通用代理类，代理类Proxy内部不在维护A，而是维护一个Object,该代理类要实现通用的代理接口InvocationHandler,该接口只有一个方法invoke()。Proxy内部维护Object,这个Object就可以代表任何上述接口,想要执行接口方法JVM就会自动调用内部invoke()方法。

invoke有三个参数：Object proxy,JVM自动生成的对应接口对象,一般不用管它、Method method：要切入的方法、Object args：切入的方法的参数

invoke()返回一个Object,在invoke()内部要使用method.invoke(obj,args)调用内部维护的Object的原始方法，然后返回

        最后想用代理时创建代理即可,要创建代理，简单，调用(XXX)Proxy.newProxyInstance()即可，直接创建代理并进行强制类型转换

该方法也有三个参数:ClassLoader loader:任意上述接口对象的类加载器、Class<?>[] interfaces:任意上述接口对象的数组、InvocationHandler h:代理

        简而言之，动态代理就是在运行时动态生成指定接口的代理用于强化接口方法，就是动态生成静态代理，在内部使用时，每次通过Proxy.newProxyInstance()指定接口与通用代理类，通用代理类的构造器传入具体的接口实现类作为参数。JVM内部自动生成一个与指定接口绑定的代理类，名为ProxyX(X是自增数字),该代理类被传入通用代理类的invoke方法中，同时将绑定到的实现接口的具体类的方法method与方法参数args一并传入invoke,然后执行invoke()中的代码，要调用原方法，须使用method.invoke(obj,args),返回一个Object作为结果，返回该结果即可

```java
public class TestDemo {
    interface IA{
        void sayA();
    }
    interface IB{
        void sayB();
    }
    static class A implements IA{
        public void sayA(){
            System.out.println("I am A");
        }
    }
    static class B implements IB{
        public void sayB(){
            System.out.println("I am B");
        }
    }
    static class MyProxy implements InvocationHandler {
        private Object obj;
        public MyProxy(Object obj){
            this.obj=obj;
        }

        public Object invoke(Object proxy, Method method,Object[] args){
            System.out.println("我是自动创建的代理"+proxy.getClass().getName());
            System.out.println("我是代理，我需要处理方法"+method.getName());
     
            if(args!=null)System.out.println("我是代理，该方法有参数"+args.length+"个");
            try{
                Object result=method.invoke(obj,args);//执行原始object方法
                return result;
            }catch (Exception e){
                e.printStackTrace();
            }
            return null;
        }
    }
     
    public static void main(String[] args){
        IA a=(IA) Proxy.newProxyInstance(IA.class.getClassLoader(),new Class<?>[]{IA.class},new MyProxy(new A()));
        a.sayA();
        IB b=(IB)Proxy.newProxyInstance(IB.class.getClassLoader(),new Class<?>[]{IB.class},new MyProxy(new B()));
        b.sayB();
    }

}
```

结果为：
我是自动创建的代理mapper.$Proxy0
我是代理，我需要处理方法sayA
I am A
我是自动创建的代理mapper.$Proxy1
我是代理，我需要处理方法sayB
I am B

### 行为型模式

行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤 立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

行为型模式分为类行为型模式和对象行为型模式两种：

 • 类行为型模式：类的行为型模式使用继承关系在几个类之间 分配行为，类行为型模式主要通过多态等方式来分配父类与 子类的职责。

 • 对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方 式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式

#### 职责链模式

 职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。 

链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并使请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，将请求的发送者和请求的处理者解耦。这就是职责链模式的模式动机。 

[![QCtxhj.md.png](https://s2.ax1x.com/2019/11/27/QCtxhj.md.png)](https://imgchr.com/i/QCtxhj)

目的是为了解耦合，将职责功能分开，确保单一职责原则的同时根据条件不同使用不同的请求处理对象，请求通过职责链一步一步往下传递，即请求往下传递直到传递到一个能解决的对象进行解决。即将多个能处理请求的对象连接成一个链，传递到能解决的对象上就进行处理（handle)

[![QCNzVO.md.png](https://s2.ax1x.com/2019/11/27/QCNzVO.md.png)](https://imgchr.com/i/QCNzVO)

模式结构 ：

 • Handler: 抽象处理者，定义一个处理请求的接口

 • ConcreteHandler: 具体处理者，实现具体请求，维护对下家的引用 

• Client: 客户类 

使用职责链必须知道上下级的关系才能以链式方式处理请求，同时下级必须知道对应的上级是谁，就像链表一样传递，但是前提是必须得知道是谁，同时可以指定分配职责，这样就更加灵活，但相应的粒度级划分的更小，会产生更多对象。因此使用职责链必须要先组装链，正如同构建链表一样，抽象类必须维护一个successor，该successor就是上级对象，提供setter()，下级通过setter()注册上级，处理不了时直接调用successor进行传递。

```java
public abstract class Leader {
    private Leader successor;//内部维护一个上级处理对象

    //通过该方法注入上级
    public void setSuccessor(Leader successor) {
        this.successor = successor;
    }

    public Leader getSuccessor() {
        return successor;
    }

    public abstract void handleRequest(String request);//必须处理请求
}
```

```java
public class HandlerA extends Leader {
    @Override
    public void handleRequest(String request){
        if(request.equals("/test/1")){
            System.out.println("A处理"+request);//可以处理请求，进行处理
        }else{
            //无法处理，获取上级，向上传递
            if(getSuccessor()==null)System.out.println("链到底");
            else getSuccessor().handleRequest(request);//获取上级处理
        }
    }
}
public class HandlerB extends Leader {
    @Override
    public void handleRequest(String request){
        if(request.equals("/test/2")){
            System.out.println("B处理"+request);//可以处理请求，进行处理
        }else{
            //无法处理，获取上级，向上传递
            if(getSuccessor()==null)System.out.println("链到底");
            else getSuccessor().handleRequest(request);
        }
    }
}
public class HandlerC extends Leader{
    @Override
    public void handleRequest(String request){
        if(request.equals("/test/3")){
            System.out.println("C处理"+request);//可以处理请求，进行处理
        }else{
            //无法处理，获取上级，向上传递
            if(getSuccessor()==null)System.out.println("链到底，无法处理");
            else getSuccessor().handleRequest(request);
        }
    }
}
```

```java
public class ChainOfResponsibilityPatternTest {
    public static void main(String[] args){
        //必须先组装链，正如同构建链表一样
        HandlerA handlerA=new HandlerA();
        HandlerB handlerB=new HandlerB();
        HandlerC handlerC=new HandlerC();
        //构建链
        handlerA.setSuccessor(handlerB);
        handlerB.setSuccessor(handlerC);

        handlerA.handleRequest("/test/2");
        handlerA.handleRequest("/test/3");
        handlerA.handleRequest("error");
    }
}
/*
B处理/test/2
C处理/test/3
链到底，无法处理
*/
```

这样处理没能屏蔽构造链的细节，可以进一步细化，创建一个专门的类专门生产链（就跟生产链表一样）

```java
public class Handler extends HandlerA{
    public Handler(){
        HandlerB handlerB=new HandlerB();
        HandlerC handlerC=new HandlerC();
        //构建链
        super.setSuccessor(handlerB);
        handlerB.setSuccessor(handlerC);
    }
}
main中：
        Handler handler=new Handler();
        handler.handleRequest("/test/3");//C处理/test/3
```

 在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理 这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织 链和分配责任。 

职责链模式的主要优点在于可以降低系统的耦合度，简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；其主要缺点在于不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。 

 职责链模式适用情况包括：有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定；在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；可动态指定一组对象处理请求。 

#### 命令模式

命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。  

模式结构：

**Command类：**是一个抽象类，类中对需要执行的命令进行声明，一般来说要对外公布一个 execute 方法用来执行命令。

**ConcreteCommand类：**Command类的实现类，对抽象类中声明的方法进行实现。内部维护Receiver，实际请求由Receiver执行

**Receiver类：**接收者，负责接收命令并且执行命令

**Invoker类：**调用者，负责调用命令。内部维护Command，通过注入不同的Command来达到执行不同命令的目的，请求接受者Receiver(也就是实际的处理者)有具体的Command来实现

仍然通过层级调用的方法通过增加层级类来达到解耦的目的，只需构造具体的Command，传递给invoker，交给invoker执行，invoker调用具体Command的execute，Command调用内部维护的Receiver执行

```java
public interface Command {
    void execute(String request);
}
public class ConcreteCommand implements Command {
    //内部维护实际接受者，解耦合，提供构造器与setter，可交给接受者去处理
    private Receiver receiver;

    public ConcreteCommand(Receiver receiver){
        this.receiver=receiver;
    }
    public void setReceiver(Receiver receiver) {
        this.receiver = receiver;
    }
    @Override
    public void execute(String request){
        System.out.println("请求到达命令者，但实际调用接受者Receiver的方法去执行");
        receiver.handle(request);
    }
}
//实际处理请求的接受者
public class Receiver {
    public void handle(String request){
        System.out.println("实际接受者，处理请求："+request);
    }
}
//调度器，调度命令，解耦合，可根据不同的请求调度不同的命令
//提供构造器与setter进行具体的命令注入
public class Invoker implements Command{
    private Command command;
    public Invoker(Command command){
        this.command=command;
    }

    public void setCommand(Command command) {
        this.command = command;
    }
    @Override
    public void execute(String request){
        System.out.println("请求到达调度器，交给Command执行");
        command.execute(request);
    }
}
```

```java
public class CommandPatternTest {
    public static void main(String[] args){
        //手动构造命令，注入Command
        Receiver receiver=new Receiver();
        Command command=new ConcreteCommand(receiver);
        command.execute("客户端请求");

        System.out.println("----------------");
        //通过调度器，注入Command
        Invoker invoker=new Invoker(command);
        invoker.execute("调度器的客户端请求");
    }
}
/*
请求到达命令着，但实际调用接受者Receiver的方法去执行
实际接受者，处理请求：客户端请求
----------------
请求到达调度器，交给Command执行
请求到达命令着，但实际调用接受者Receiver的方法去执行
实际接受者，处理请求：调度器的客户端请求
*/
```

把一条命令的执行分三步，引入invoker将命令的调度者与执行者分开，客户只需要知道具体命令Command，传入invoker然后调用方法执行即可，根本不用管命令如何实现，原理还是通过层级调用，引入层次依赖解决当前的高度耦合

命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统 有过多的具体命令类。 

命令模式适用情况包括：需要将请求调用者和请求接收者解耦， 使得调用者和接收者不直接交互；需要在不同的时间指定请求、 将请求排队和执行请求；需要支持命令的撤销操作和恢复操作。

#### 解释器模式

 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。 即对两个不同的表达方式进行转换，正如同现实世界中各种语言的翻译解释一样，给定规定的语言文法表示，翻译成相应的可执行的语句。除了使用文法规则来定义一个语言，在解释器模式中还可以通过一种称之为抽象语法树 (Abstract Syntax Tree, AST)的图形方式来直观地表示语言的构成，每一棵抽象语法树对应一个语言实例，通过分析抽象语法树进行解释执行。

一些ORM框架就通过特定的方法限定语法规则，完成对sql语句的拼接，即只写java代码而不用写sql语句，这也算是解释器模式的一个实例。

模式结构

 • AbstractExpression: 抽象表达式，内部定义抽象方法interpect()表示可以有多种不同的具体解释

 • TerminalExpression: 终结符表达式 

• NonterminalExpression: 非终结符表达式，抽象表达式的具体实现，定义具体的语法解析 

• Context: 定义语法的上下文

来自：https://zhuanlan.zhihu.com/p/62426301 的例子：

```java
/**
 * 定义上下文语法规则，拼接SQL时需要的 表名、字段参数、条件参数
 */
public class Context {
    private String tableName;
    private Map<String, Object> params = new HashMap<>();
    private Map<String, Object> wheres = new HashMap<>();

    public String getTableName() {
        return tableName;
    }

    public void setTableName(String tableName) {
        this.tableName = tableName;
    }

    public Map<String, Object> getParams() {
        return params;
    }

    public void setParams(Map<String, Object> params) {
        this.params = params;
    }

    public Map<String, Object> getWheres() {
        return wheres;
    }

    public void setWheres(Map<String, Object> wheres) {
        this.wheres = wheres;
    }
}
```

```java
/**
 * 定义抽象解释器，可以有多种不同的具体实现去解释文法
 */
public abstract class SQLExpression {
    public abstract String interpret(Context context);
}
//具体的解释器去实现具体的文法解析工作
public class SelectSQLExpression extends SQLExpression{

    @Override
    public String interpret(Context context) {
        StringBuilder select = new StringBuilder();
        select.append("select * from ")
                .append(context.getTableName())
                .append(" where ");
        for (String key : context.getWheres().keySet()) {
            select.append(key)
                    .append(" = '")
                    .append(context.getWheres().get(key))
                    .append("'")
                    .append(" and ");
        }

        return select.substring(0,select.length()-4);
    }
}
```

```java
public class InterpreterPatternTest {
    public static void main(String[] args) {
        Context context = new Context();
        context.setTableName("user");
        context.setParams(null);

        Map<String, Object> wheres = new HashMap<>();
        wheres.put("name", "小明");
        context.setWheres(wheres);

        SQLExpression sqlExpression = new SelectSQLExpression();
        System.out.println(sqlExpression.interpret(context));
    }
}
/*
select * from user where name = '小明' 
*/
```

Context定义文法信息，解释器Interpreter就是要根据文法去进行解释工作，需要解释器工作的地方面临着全局的抽象转换需求。

 解释器模式的主要优点包括易于改变和扩展文法，易于实现文法并可以按需增加新的解释表达式的方式

其主要缺点是对于复杂文法难以维护，执行效率较低且应用场景很有限，实际中较少用到解释器

#### 迭代器模式

一个聚合对象，如一个列表(List)或者一个集合(Set)，应该提供一种方法来让别人可以访问它的元素，而又不需要暴露它的内部结构。针对不同的需要，可能还要以不同的方式遍历整个聚合对象， 但是我们并不希望在聚合对象的抽象层接口中充斥着各种不同遍历的操作。  遍历一个聚合对象，不需要了解聚合对象的内部结构， 还能够提供多种不同的遍历方式，这就是迭代器模式要解决的问题。

在迭代器模式中，提供一个外部的迭代器来对聚合对象进行访问和遍历，迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有。 

 模式结构：

 • Iterator: 抽象迭代器 ，定义迭代一个对象所需要的功能

• ConcreteIterator: 具体迭代器，迭代器接口的对象

 • Aggregate: 抽象聚合类，内部维护数据对象的数据结构

 • ConcreteAggregate: 具体聚合类 

很多语言已经内置了迭代器与forEach迭代语法，更具体的，在java中，使用Iterable接口表示可迭代，内部有iterator()方法返回一个迭代器，Iterator()接口表示真正的迭代器，通过该接口进行操作，具体的集合类实现Iterable接口，返回iterator对象，自己实现自己的迭代操作，外部不需要知道集合如何遍历元素，只管使用返回来的迭代器即可，这个设计很“解耦”

```java
/**
 * 声明迭代器，实现该接口就代表该类可以进行内部元素迭代，返回一个迭代器
 */
public interface Iterable<E> {
    Iterator<E> iterator();
}
/**
 * 迭代器声明，不需要管实现，遵循迭代规则即可
 */
public interface Iterator<E> {
    E first();
    boolean hasNext();
    E next();
    E currentItem();
}
//具体使用
public class Aggregate<E> implements Iterable{
    private List<E> list=new ArrayList<>();
    private int currentCursor=0;
    public void add(E element){
        list.add(element);
    }

    /**
     * 返回迭代器即可，外部不需要管内部实现
     */
    @Override
    public Iterator iterator(){
        return new Iterator() {
            @Override
            public Object first() {
                if(list.size()==0)throw new ArrayIndexOutOfBoundsException();
                return list.get(0);
            }

            @Override
            public boolean hasNext() {
                return currentCursor<list.size();
            }

            @Override
            public Object next() {
                if(currentCursor>=list.size())throw new ArrayIndexOutOfBoundsException();
                return list.get(currentCursor++);
            }

            @Override
            public Object currentItem() {
                return list.get(currentCursor);
            }
        };
    }
}

```

```java
public class IteratorPattern {
    public static void main(String[] args){
        Aggregate<Integer> aggregate=new Aggregate<Integer>();
        aggregate.add(3);
        aggregate.add(2);
        aggregate.add(1);

        Iterator iterator=aggregate.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.currentItem());
            iterator.next();//迭代
        }
    }
}
/*
3
2
1
*/
```

迭代器模式的主要优点在于它支持以不同的方式遍历一个聚合对象，还简化了聚合类，而且在同一个聚合上可以有多个遍历；其缺点在于增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 迭代器模式适用情况包括：访问一个聚合对象的内容而无须暴露它的内部表示；需要为聚合对象提供多种遍历方式；为遍历不同的聚合结构提供一个统一的接口。

#### 中介者模式

用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式。

中介者模式可以使对象之间的关系数量急剧减少： 

[![QYrniQ.md.png](https://s2.ax1x.com/2019/12/06/QYrniQ.md.png)](https://imgse.com/i/QYrniQ)

模式结构：

（1）Mediator：抽象中介者，它定义了对象之间交流的方法。就好比国与国之间的沟通方式。

（2）ConcreteMediator：具体中介者，联合国的正式组成运营。

（3）Colleague：抽象同事类，就好比是一个抽象的国家模型。里面定义了一些功能。

（4） ConcreteColleague: 具体同事类。就好比是一个个具体的国家，英国、美国。

还是为了解耦合，如果有多个Colleague要互相通信，通知者必须内部维护被通知者，对象一多，会产生大量的耦合代码。抽象中介者Mediator内部定义对象之间的交互方式，具体中介者ConcreteMediator内部维护一个Colleage的列表，进行Colleage通信调度。Colleague抽象出通信功能，具体子类内部维护Mediator，实现功能时调用Mediator的方法进行交互，传递必要信息，交给Mediator调度，内部不再维护其它Colleague，实现解耦合。

```java
/**
 * 抽象中介者，定义中介的功能
 */
public interface Mediator {
    //定义交互功能
    void communicate(String msg,Colleague from,String to);
}
public class ConcreteMediator implements Mediator {
    //中介者维护所有要交互的Colleague的信息，进行统一的交互管理
    public List<Colleague> colleagues=new ArrayList<>();

    //具体的交互管理
    @Override
    public void communicate(String msg, Colleague from,String to) {
        //消息传递
        for(Colleague colleague:colleagues){
            if (colleague.getName().equals(to)){
                colleague.receiveMsg(msg);
            }
        }
    }
}
```

```java
/**
 * 抽象交互类Client，定义与其他Colleague交互功能
 */
public abstract class Colleague {
    protected String name;
    protected Mediator mediator;//定义中介者
    Colleague(String name,Mediator mediator){
        this.name=name;
        this.mediator=mediator;
    }
    public String getName() {
        return name;
    }

    //定义交互功能
    public abstract void sendMsg(String msg,String to);
    public abstract void receiveMsg(String msg);
}
/**
 * 具体的Colleague,内部的交互方法教给中介者mediator而不是自己内部维护Colleague对象交互，解耦合
 */
public class AColleague extends Colleague {
    AColleague(String name,Mediator mediator){
        super(name,mediator);
    }
    //调用中介者的方法进行通知交互而不是维护另一个Colleague对象，进行解耦合
    @Override
    public void sendMsg(String msg,String to) {
        mediator.communicate(msg,this,to);//交给中介者调度
    }

    @Override
    public void receiveMsg(String msg) {
        System.out.println("A获得信息:" + msg);
    }

}
public class BColleague extends Colleague {
    BColleague(String name,Mediator mediator){
        super(name,mediator);
    }
    //调用中介者的方法进行通知交互而不是维护另一个Colleague对象，进行解耦合
    @Override
    public void sendMsg(String msg,String to) {
        mediator.communicate(msg,this,to);
    }

    @Override
    public void receiveMsg(String msg) {
        System.out.println("B获得信息:" + msg);
    }
}
```

```java
public class MediatorPatternTest {
    public static void main(String[] args){
        ConcreteMediator mediator=new ConcreteMediator();
        AColleague aColleague=new AColleague("a",mediator);
        BColleague bColleague=new BColleague("b",mediator);
        mediator.colleagues.add(aColleague);
        mediator.colleagues.add(bColleague);

        //使用中介者
        aColleague.sendMsg("lsl","b");
        bColleague.sendMsg("sls","a");
    }
}
/*
B获得信息:lsl
A获得信息:sls
*/
```

 通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互， 还可以对对象间的交互进行进一步的控制。 

中介者模式的主要优点在于简化了对象之间的交互，将各同事解耦， 还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者， 可以简化各同事类的设计和实现；中介者模式主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。 

中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 

#### 备忘录模式

在应用软件的开发过程中，很多时候我们都需要记录一个对象的内部状态。 在具体实现过程中，为了允许用户取消不确定的操作或 从错误中恢复过来，需要实现备份点和撤销机制，而要实现这些机制，必须事先将状态信息保存在某处，这样才能将对象恢复到它们原先的状态。 备忘录模式是一种给我们的软件提供后悔药的机制，通过它可以使系统恢复到某一特定的历史状态。  

备忘录模式(Memento Pattern)：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。其别名为Token。

[![QwOEt0.md.png](https://s2.ax1x.com/2019/12/09/QwOEt0.md.png)](https://imgse.com/i/QwOEt0) 

模式结构：

**Originator**(发起人)：负责创建一个备忘录**Memento**，用以记录当前时刻它的内部状态，并可使用备忘录恢复状态。**Originator**可根据需求决定**Memento**存储**Originator**的哪些内部状态。

**Memento**(备忘录)：负责存储**Originator**对象的内部状态，并可防止**Originator**以外的其他对象访问备忘录**Memento**。备忘录有两个接口，**Caretaker**只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。**Originator**能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。

**Caretaker**(管理者)：负责保存好备忘录**Memento**，不能对备忘录的内容进行操作或检查。

```java
//发起人，需要保存状态的对象
public class Originator {

    //需要保存的属性
    private String state;

    //创建备忘录，将当前需要保存的信息导入并实例化出一个Memento对象
    public Memento createMemento() {
        return new Memento(state);
    }

    //恢复备忘录，将Memento导入并将相关数据恢复为传递进来的Memento
    public void setMemento(Memento memento) {
        this.state = memento.getState();
    }

    //显示数据
    public void show() {
        System.out.println("state = " + state);
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}
```

```java
//备忘录，保存实际状态
public class Memento {

    private String state;

    //构造方法，将相关数据导入
    public Memento(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}
//管理者，内部维护备忘录对象
public class Caretaker {

    private Memento memento;

    public Memento getMemento() {
        return memento;
    }

    public void setMemento(Memento memento) {
        this.memento = memento;
    }
}
```

```java
public class Client {
    public static void main(String[] args) {
        Originator originator = new Originator();
        originator.setState("On");
        originator.show();

        Caretaker caretaker = new Caretaker();
        caretaker.setMemento(originator.createMemento());//创建备忘录导出状态交给Caretaker保存

        originator.setState("Off");
        originator.show();

        originator.setMemento(caretaker.getMemento());//从Caretaker中拿出保存的状态
        originator.show();
    }
}
/*
state = On
state = Off
state = On
*/
```

Originator是需要进行备忘的类，内部维护需要进行备忘的对象，通过返回一个Memento导出备忘对象，备忘录Memento内部维护需备忘的对象，由Originator导出保存以前的值，Caretaker用于管理Memento，内部维护Memento列表，当Originator需要恢复到以前的状态时通过调用Caretaker获取以前Originator导出的备忘录。

备忘录模式的主要优点在于它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，还简化了原发器对象，备 忘录只保存原发器的状态，采用堆栈来存储备忘录对象可以实现多次撤消操作，可以通过在负责人中定义集合对象来存储多个备忘录；

备忘录模式的主要缺点在于资源消耗过大，因为每一个历史状态的保存 都需要一个备忘录对象。 

备忘录模式适用情况包括：保存一个对象在某一个时刻的状态或部分状态，这样以后需要时它能够恢复到先前的状态；如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。 

#### 观察者模式

建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。 在此，**发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者**，使得系统更易于扩展，这就是观察者模式的模式动机。 

即定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时， 其相关依赖对象皆得到通知并被自动更新。

模式结构：

 • Subject: 目标，定义增删观察者、向观察者发送通知的方法

 • ConcreteSubject: 具体目标 ，内部维护观察者列表，当状态改变时通知观察者

• Observer: 观察者 ，定义接收通知后将调用的更新方法

• ConcreteObserver: 具体观察者 

[![QrIKKJ.md.png](https://s2.ax1x.com/2019/12/11/QrIKKJ.md.png)](https://imgse.com/i/QrIKKJ)

```java
/**
 * 观察者，定义被通知之后将要执行的功能
 */
public interface Observer {
    void update();
}
public class AObserver implements Observer {
    @Override
    public void update(){
        System.out.println("A已被通知，执行操作");
    }
}
public class BObserver implements Observer {
    @Override
    public void update(){
        System.out.println("B已被通知");
    }
}
/**
 * 被观察者Observable，也是订阅者，或者主题，定义增删观察者，执行通知的功能
 */
public interface Submit {
    void attach(Observer observer);
    void detach(Observer observer);
    void notifyObservers();
}
public class ConcreteSubject implements Submit{
    private List<Observer> observerList=new ArrayList<>();

    @Override
    public void attach(Observer observer){
        observerList.add(observer);
    }

    @Override
    public void detach(Observer observer){
        observerList.remove(observer);
    }

    @Override
    public void notifyObservers(){
        for(Observer observer:observerList){
            observer.update();//调用观察者，执行观察者方法
        }
    }

    public static void main(String[] args){
        Submit submit=new ConcreteSubject();
        submit.attach(new AObserver());
        submit.attach(new BObserver());

        submit.notifyObservers();
    }
}
/*
A已被通知，执行操作
B已被通知
*/
```

观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变， 所有的观察者都将得到通知。 作为对这个通知的响应，每个观察者都将即时更新自己的状态， 以与目标状态同步，这种交互也称为发布-订阅(publishsubscribe)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。 

观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离， 在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话， 将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用， 可能导致系统崩溃。 

观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。 在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。

#### 状态模式 

允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

 模式结构 ：

 • Context: 环境类，内部维护抽象状态State，根据条件设置具体的State，不同的状态下可以执行不同的操作

 • State: 抽象状态类 ，定义所有状态下可能执行的不同操作

• ConcreteState: 具体状态类 ，定义某一具体状态下允许执行的操作

状态模式描述了对象状态的变化以及对象如何在每一 种状态下表现出不同的行为。状态模式的关键是引入了一个抽象类来专门表示对象的状态，这个类我们叫做抽象状态类，而对象的每一种具体状态类都继承了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。

状态模式通常用于描述现实状态下个体不同状态时所能执行的操作（如打游戏时，用户每升一级就是一个不同的状态）

[![QrbsgK.md.png](https://s2.ax1x.com/2019/12/11/QrbsgK.md.png)](https://imgse.com/i/QrbsgK)

不使用状态模式时，每一次进行状态判断都需要判断多个条件，状态模式封装了具体状态下的可执行操作，按照条件设置状态即可。使用时内部维护抽象状态State，根据条件设置具体的State，不同的状态下可以执行不同的操作

```java
/**
 * 抽象状态对象
 */
public abstract class LevelState {
    public void A(){System.out.println("技能A不可释放");}
    public void B(){System.out.println("技能B不可释放");}
}
public class OneLevelState extends LevelState {
    @Override
    public void A(){
        System.out.println("技能A可以释放");
    }
}
public class TwoLevelState extends LevelState {
    @Override
    public void A(){
        System.out.println("技能A可以释放");
    }
    @Override
    public void B(){
        System.out.println("技能B可以释放");
    }
}
```

```java
public class Player {
    private LevelState state;

    public LevelState getState() {
        return state;
    }

    public void setState(LevelState state) {
        this.state = state;
    }

    public static void main(String[] args){
        Player player=new Player();
        //（根据条件）设置状态
        player.setState(new OneLevelState());
        player.getState().A();
        player.getState().B();

        player.setState(new TwoLevelState());
        player.getState().A();
        player.getState().B();
    }
}
/*
技能A可以释放
技能B不可释放
技能A可以释放
技能B可以释放
*/
```

 状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；

其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切 换状态的状态模式不满足“开闭原则”的要求。 

状态模式适用情况包括：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。 

#### 策略模式

在软件系统中，有许多算法可以实现某一功能，如查找、排序等， 一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。 

 为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。 

即定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。 

模式结构：

 • Context: 环境类，要调用策略执行功能的类

 • Strategy: 抽象策略类，定义策略要实现的功能

 • ConcreteStrategy: 具体策略类 ，功能的具体实现

[![Q6KGY4.md.png](https://s2.ax1x.com/2019/12/12/Q6KGY4.md.png)](https://imgse.com/i/Q6KGY4)

```java
//策略类，定义抽象算法功能
public abstract class Strategy {
    public abstract void algorithm();
}
public class AStrategy extends Strategy {
    @Override
    public void algorithm(){
        System.out.println("执行A算法");
    }
}
public class BStratery extends Strategy{
    @Override
    public void algorithm(){
        System.out.println("执行B算法");
    }
}
public class Context {
    private Strategy strategy;
    public Context(Strategy strategy){
        this.strategy=strategy;
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    public void algorithm(){
        strategy.algorithm();
    }

    public static void main(String[] args){
        Context context=new Context(new AStrategy());
        context.algorithm();
        context.setStrategy(new BStratery());
        context.algorithm();
    }
}
/*
执行A算法
执行B算法
*/
```

策略模式的思想就是将原来庞大的算法集合按类别分开来，抽象出公共的算法问题定义Strategy，交给子类进行不同的实现，同时在来一个类Context内部维护一个Strategy，客户端根据需要注入不同的具体Strategy，实现一定程度上的解耦。

策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法， 它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定 程度上增加了系统中类的个数，可能会存在很多策略类。 

策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。 

#### 模板方法模式

模板方法模式是一种类的行为型模式，在它的结构图中只有类之间的继承关系，没有对象关联关系。 

在模板方法模式的使用过程中，要求开发抽象类和开发具体子类的设计师之间进行协作。一个设计师负责给出一个 算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。实现这些具体逻辑步骤的方法称为基本方 法(Primitive Method)，而将这些基本法方法汇总起来的方法称为模板方法(Template Method)，模板方法模式的名字从此而来。 
模板方法模式 ：一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。 

 基本方法：基本方法是实现算法各个步骤的方法，是模板方法的组成部分。

 • 抽象方法(Abstract Method) 

• 具体方法(Concrete Method) 

• 钩子方法(Hook Method)：“挂钩”方法和空方法 ，不是抽象方法但没有实现，子类按需实现

[![QfHWd0.md.png](https://s2.ax1x.com/2019/12/15/QfHWd0.md.png)](https://imgse.com/i/QfHWd0)

模板方法模式将一整套业务流程抽象出来，任何用户使用时都需要根据该流程进行，因此抽象类定义整个业务流程所需要的方法，提供模板方法一次调用所需要的方法完成业务流程，不同的子类有自己的业务条件实现，关键在于模板方法的实现，该方法定义了基本方法执行的顺序。

```java
/**
 * 抽象类，定义业务流程方法及执行逻辑
 */
public abstract class DBOperator {
    public abstract void connDB(String address);
    public void openDB(String address){
        System.out.println("打开"+address);
    }
    public void useDB(String sql){
        System.out.println("执行SQL"+sql);
    }
    public void closeDB(String address){
        System.out.println("关闭"+address);
    }
    public void process(String address,String sql){
        connDB(address);
        openDB(address);
        useDB(sql);
        closeDB(address);
    }

}
/**
 * 不同的业务流程实现子类
 */
public class SQLServerDB extends DBOperator{
    public void connDB(String address){
        System.out.println("连接SQLServer"+address);
    }
}
public class OracleDB extends DBOperator {
    public void connDB(String address){
        System.out.println("连接Oracle"+address);
    }

    public static void main(String[] args){
        DBOperator dbOperator=new SQLServerDB();
        dbOperator.process("127.0.0.1:8080","test1");

        dbOperator=new OracleDB();
        dbOperator.process("127.0.0.1:8080","test2");
    }
}
```

 模板方法模式的优点在于在子类定义详细的处理算法时不会改变算法的结构，实现了代码的复用，通过对子类的扩展可以增加新的行为，符合“开闭原则”；其缺点在于需要为每个不同的实现都定义一个子类，这会导致类的个数 增加，系统更加庞大，设计也更加抽象

模板方法模式适用情况包括：一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现；各子类中公共 的行为应被提取出来并集中到一个公共父类中以避免代码重复；对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法，而一些可以改变的细节由其子类来实现；通过模板方法模式还可以控制子类的扩展。 

#### 访问者模式

对于系统中的某些对象，它们存储在同一个集合中，且具有不同的类型，而且对于该集合中的对象，可以接受一类称为访问者的对象来访问，而且不同的访问者其访问方式有所不同，访问者模式为解决这类问题而诞生。

即表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

[![Qfq4v4.md.png](https://s2.ax1x.com/2019/12/15/Qfq4v4.md.png)](https://imgse.com/i/Qfq4v4)

问题的关键在于可以以不同的方式访问元素集合内不同的元素，由客户端决定以什么方式访问什么元素

模式结构： 

• Vistor: 抽象访问者，定义要以何种方式访问何种元素

• ConcreteVisitor: 具体访问者

 • Element: 抽象元素，某个集合内要存放的元素

 • ConcreteElement: 具体元素 

 • ObjectStructure: 对象结构，存放抽象元素的集合

 ```java
/**
 * 抽象元素类型，定义访问者访问方法
 */
public interface Element {
    void accept(Visitor visitor);
}
/**
 * 具体元素实现，访问元素时根据Visitor调用访问
 */
public class ConcentrateElementA implements Element {
    @Override
    public void accept(Visitor visitor){
        visitor.visitConcentrateElementA(this);
    }
}
public class ConcentrateElementB implements Element {
    @Override
    public void accept(Visitor visitor){
        visitor.visitConcentrateElementB(this);
    }
}
/**
 * 具体访问者提供对元素的具体访问方法
 */
public class ConcentrateVisitorA implements Visitor {
    @Override
    public void visitConcentrateElementA(ConcentrateElementA concentrateElementA){
        System.out.println("第一种方式访问元素A");
    }
    @Override
    public void visitConcentrateElementB(ConcentrateElementB concentrateElementB){
        System.out.println("第一种方式访问元素B");
    }
}
public class ConcentrateVisitorB implements Visitor{
    @Override
    public void visitConcentrateElementA(ConcentrateElementA concentrateElementA){
        System.out.println("第二种方式访问元素A");
    }
    @Override
    public void visitConcentrateElementB(ConcentrateElementB concentrateElementB){
        System.out.println("第二种方式访问元素B");
    }
}
public class Test {
    public static void main(String[] args){
        List<Element> list=new ArrayList<>();//抽象元素集合
        list.add(new ConcentrateElementA());
        list.add(new ConcentrateElementB());
		//由客户端决定以什么方式访问什么元素
        Visitor visitor=new ConcentrateVisitorA();
        for(Element element:list){
            element.accept(visitor);
        }
        visitor=new ConcentrateVisitorB();
        for(Element element:list){
            element.accept(visitor);
        }
   }
 }
/*
第一种方式访问元素A
第一种方式访问元素B
第二种方式访问元素A
第二种方式访问元素B
*/
 ```

 访问者模式的主要优点在于使得增加新的访问操作变得很容易，将有关元素对象的访问行为集中到一个访问者对象中，而不是分散到一个个的元素类中，还可以跨过类的等级结构访问属于不同的等级结构的元素类，让用户能够在不修改现有类层次结构的情况下，定义该类层次结构的操作；其主要缺点在于增加新的元素类很困难，而且在一定程度上破坏系统的封装性。

 访问者模式适用情况包括：一个对象结构包含很多类型的对象，希望对这些对象实施一些依赖其具体类型的操作；需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作 “污染”这些对象的类，也不希望在增加新操作时修改这些类；对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 

