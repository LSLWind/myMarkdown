概述

**编译程序**：将高级语言的源程序翻译成与之等价的低级语言的目标程序的这样一种程序

**源程序运行过程**：编译阶段+运行阶段或者编译阶段+汇编阶段+运行阶段

**解释程序**：以源程序作为输入，但不产生目标程序，解释一条执行一条

**汇编程序**：用于特定计算机上的汇编语言的翻译程序。有时编译器把汇编语言作为目标语言，然后再由汇编程序将它翻译成目标代码。

**连接程序**：将分别在不同的目标文件中编译或汇编的代码收集到一个可直接执行的文件中

**装入程序**：编译器、汇编程序或连接程序生成的代码还不能运行，装入程序处理所有的与指定的基地址有关的可重定位地址，并将修改后的指令和数据放在内存中适当的位置。

**预处理程序**：预处理程序是在真正的编译开始之前由编译器调用的独立程序。预处理程序可以删除注释、包含其它文件以及执行宏替代。

**源程序+初始数据→解释程序→计算结果**

**源程序→编译程序→初始数据+目标程序+运行系统子程序→计算结果**

### 编译过程

一般分为5个阶段：词法分析→语法分析→语义分析与中间代码产生→优化→目标代码生成

* 词法分析：按照语言的词法规则使用特定的工具将源程序转换成单词符号串
* 语法分析：按照语法规则使用上下文无关文法、确定的下推自动机将单词符号串转换为各类语法范畴 （层次结构分析）
* 语义分析与中间代码产生：按照语义规则使用属性文法将语法范畴进行初步翻译、产生中间代码（中间代码即独立于具体硬件的记号系统，四元式、三元式、逆波兰式等。）
* 优化：按照等价变换规则使用变换方法将中间代码变为更高效的中间代码
* 目标代码生成：将中间代码转换成依赖于机器的目标代码

[<img src="https://s2.ax1x.com/2020/02/11/1okNmF.png" alt="1okNmF.png" style="zoom:67%;" />](https://imgchr.com/i/1okNmF)

**表格管理程序**：登记源程序的各类信息和编译程序各阶段的进展情况，如符号表。

**出错处理程序**：发现并指出源程序中错误的性质和位置；自动校正错误

**遍**：对源程序或源程序的中间结果从头至尾扫描一次，并作有关的加工处理，生成新的中间结果或目标程序的处理过程称为一遍。可以把一个阶段分为若干遍，也可以把多个阶段合为一遍，通常有一遍和多遍编译程序。

**前端（front end）**：由与源语言有关但与目标机无关的部分组成。

**后端（back end）**：包括与目标机有关的部分。而一般不依赖于源语言，只与中间代码有关的编译阶段。

[<img src="https://s2.ax1x.com/2020/02/11/1oAVhR.md.png" alt="1oAVhR.md.png" style="zoom:67%;" />](https://imgchr.com/i/1oAVhR)

### 文法基础

程序语言是符号语言，即一个记号系统，它主要有语法、语义和语用等三方面定义。

**语法**：是对语言结构的定义（什么样的符号序列是合法的）。任何语言程序都可看成是一定字符集上的一字符串（有限序列），语法定义语言的词法和语法的形式规则。

* 字母表是一个有限的字符集，字符集中的字符是语言程序中可能出现的字符，它们是语言程序单词的组成部分。
* 词法规则定义了语言程序中单词符号的形成规则。即什么样的字符串是一个合法的单词。如标识符、数值常量、运算符等单词的构成规则。
* 语法规则定义了语言程序中语法单位的形成规则。一般语言的语法单位有表达式、语句、分程序、函数、过程和程序等。描述语法规则和进行语法分析的有效工具是上下文无关文法。

**语义**：描述语言的含义；定义语言的单词符号和语法单位的意义。目前编译程序中常用的语义分析方法是一种基于属性文法的语法制导翻译。即在语法分析的同时对其中识别出的语法单位进行语义的分析与翻译工作；在描述文法的同时为定义的语法范畴加上它们的属性计算规则，属性可以是语法范畴的类型、地址、取值、执行动作等信息。

**语用**：是从使用的角度去描述语言。定义程序设计技术和语言成分的使用方法，它使语言的基本概念与语言的外界（如数学概念或计算机的对象和操作）联系起来

**字母表(alphabet)**：字母表是元素的非空有穷集合，任何语言的字母表指出了该语言中允许出现的一切符号。

```
【例如】	∑ = {a,b,c}
∑是字母表，由 a,b,c 三个元素组成。
C 语言的字母表是字母、数字和若干专用符号组成。
```

**符号(symbol)**：字母表中的元素称为符号，或称为字符。

```
【例如】	∑ = {a,b,c}
a,b,c 是字母表 ∑ 中的符号。
```

**符号串（string）**:符号的有穷序列称为字符串。符号串总是建立在某个特定字母表上的且只能由字母表上的有穷多个符号组成。不包含任何符号的符号串，称为空符号串，用$\epsilon$(epsilon)表示

```
【例如】设有字母表 ∑ = {a,b,c}，
则有符号串 a,b,ab,ba,cba,abc,…
(a,b,ab,ba,cba,abc 等都是字母表∑上的符号串)
```

**符号串的连结 catenation**：设 x 和 y 是符号串，则串 xy 称为它们的连结。

```
【例如】设 x ＝ abc，y = 10a，
则 xy ＝ abc10a
则 yx ＝ 10aabc
```

特别，对任意一符号串 x 有：$\epsilon x=x \epsilon=x$

**集合的乘积 product**：设 A 和 B 是符号串的集合，则 A 和 B 的乘积定义为：AB = {xy | x ∈ A, y ∈ B}

```
【例如】设 A = {a,b}, B = {c,d}
则 AB ＝ {ac,ad,bc,bd}
```

**空集 Φ empty set**：Φ 表示不含任何元素的空集 { }

**符号串的幂运算 power**：设 x 是符号串，则 x 的幂运算定义为：
$$
x^0 ＝ \epsilon ;x^1 ＝ x;x^2 ＝ xx……x^n ＝ xx…x
$$

集合的幂运算同理，只不过$A^0=\{\epsilon\}$

**集合A的正闭包A+与闭包A**：设 A 是符号串的集合，则集合 A 的正闭包 A+ 和闭包 A* 定义为：
$$
A^+＝ A^1 U A^2 U A^3 U … U A^n U …\\\\
A^* ＝ A^0 U A^1 U A^2 U A^3 U … U A^n U … = \{ \epsilon \} U A^+
$$

$$
【例如】设 A = \{a,b\},则\\\\
	A^+ ＝ \{a,b,aa,ab,ba,bb,aaa,aab,…\}	\\\\
	A* ＝ \{\epsilon,a,b,aa,ab,ba,bb,aaa,aab,…\}
$$

### 形式语言和文法

**形式语言**：序列(字符串)的集合称为形式语言。每个形式语言都是某个字母表上按某种规则构成的所有符号串的集合；任何一个字母表上符号串的集合均可定义一个形式语言。

```
【例如】
C 语言是具有基本符号字母表上的符号串的集合。每个 C 语言程序是基本符号的符号串。
```

形式语言的描述有两种方法：

1. 当语言为有穷集合时，用枚举法来表示语言。

```
【例】设有字母表 A={a,b,c},则L1 ＝ {a,b,c},L2 ＝ {a,aa,ab,ac},L3 ＝ {c,cc}均表示字母表 A 上的一个形式语言。由于这三个语言均是有限符号串的集合，可以枚举出其全部句子来表示该语言。
```

2. 当语言为无穷集合时，需要设计文法来描述无穷集合的语言。

$$
【例】设有字母表 ∑=\{0,1\},\\\\
则∑^+ ＝ ∑^1 \bigcup∑2 \bigcup ∑3 \bigcup …  = 						\{0,1,00,10,11,01,000,100,…\}\\\\
用 A 表示 ∑^+，用式子 A→0 表示符号串 0∈A 或 A 生成符号串 0
则集合 A 可表示成：\\\\A→0;A→1;A→A0;A→A1
$$

显然由 A 生成的符号串属于 ∑+，这就是文法描述语言，它描述了无穷集合的语言。

**文法的形式定义**：

**规则**：规则也称产生式，它是一个符号与一个符号串的有序对（A,$\beta$），通常写做A→$\beta$（ 或 A::=$\beta$ ）

其中 A 是规则左部，是一个符号；$\beta$是规则右部，是一个符号串。→ 或 ::= 表示“定义为”或“生成”，意思是左部符号用右部符号串定义或左部符号生成右部符号串。规则的作用是告诉如何用规则中的符号串生成语言中的序列。一组规则规定了一个语言的语法结构。

非终结符：出现在产生式左部能派生出符号或符号串的那些符号，即每个非终结符表示一定符号串的集合。用大写字母表示或用尖括号把非终结符括起来。
终结符：是不属于非终结符的那些符号，它是组成语言的基本符号，是一个语言的不可再分的基本符号，只出现在产生式右部。通常用小写字母表示。

```
【例】产生式	A→A1 A→A0
	A 是非终结符，0、1 是终结符
```

**文法**：文法是规则的非空集合，是一个四元式G =（$V_N$，$V_T$，P，S），其中：

* $V_N$  是一个非空有限集，它的每个元素为非终结符号， 
* $V_T$  是一个非空有限集，它的每个元素为终结符号； $V_T$ ∩ $V_N$  = Φ 
* S 是一个非终结符号，称为开始符号或识别符号；开始符号 S 至少必须在某个产生式的左部出现一次。
* P 是一个产生式集合（有限），每个产生式的形式是P→α，其 P ∈ $V_N$ ， α ∈ ($V_T$∪$V_N$)*。

左部相同的产生式，如A→α1， A→α2， …， A→αn，可合并为一个，缩写为A→ α1|α2| … |αn 

### 设计文法示例

**例1**

设字母表∑＝{a,b},试设计文法，描述语言  L={$a^{2n}$，$b^{2n}$ |  n≥1}

分析：设计文法来描述一个语言，关键是设计一组规则生成语言中的符号串。设计语言的文法，必须分析这个语言是由怎样一些符号串组成，即首先分析语言中符号串的结构特征：

```
当 n=1		L = {aa,bb}
当 n=2		L = {aaaa,bbbb}
当 n=3		L = {aaaaaa,bbbbbb}
…
L = {aa,bb,aaaa,bbbb,aaaaaa,bbbbbb,…}
语言 L 是由偶数个 a，偶数个 b 这样的符号串组成的集合。
```

$$
文法1：G =（V_N，V_T，S，P），其中\\\\
	V_N = \{A, B, D\}\\\\
    V_T = \{a, b\}\\\\
    P = \{ A→aa | aaB | bb | bbD\\\\
    B→aa | aaB\\\\	
    D→bb | bbD \}\\\\
    S = A
$$

很显然，a,b是终结符，非终结符A定义完整L，需要终结符B、D来描述A，按照逻辑，该文法能描述语言L，此外，描述该语言的文法不是唯一的。
$$
文法2：G' =（V_N，V_T，S，P），其中\\\\
	V_N = \{A, B, D\}\\\\
    V_T = \{a, b\}\\\\
    P = \{ A→B|D\\\\
    B→aa | aBa\\\\	
    D→bb | bDb \}\\\\
    S = A
$$
G 和 G’ 是两个的文法，如果它们描述的语言相同，那么称 G 和 G’ 为等价文法。

**例2**

设计一个表示所有标识符的文法

分析：标识符的定义是字母或以字母开头的字母数字串（此处先不考虑大写字母）

显然，终结符是字母数字集合{a-z}∪{0-9}中的元素，标识符语言={字母*字母,字母\*数字}，因此设计文法
$$
用 I 表示标识符，L 代表字母，D 代表数字，定义标识符的文法为：G =（VN，VT，P，S）其中：\\\\
V_N = \{I,L,D\}\\\\
V_T = \{a,b,…,x,y,z,0,1,2,…,9\}\\\\
P = \{ I→L | IL |ID\\\\
L→ a | b | … | x | y | z\\\\
D→ 0 | 1 | … |9 \}\\\\
S = I
$$
**例3**

用文法定义一个含+、*、()的算术表达式。

分析：变量是表达式；若 E1 和 E2 是算术表达式，则 E1+E2，E1*E2，(E) 也是算术表达式。
$$
G =（V_N，V_T，P，S）其中：\\\\
V_N = \{ E \}\\\\	
V_T = \{ i,+,*,(,) \}\\\\
P = \{ E →i | E+E | E*E |(E) \}\\\\
S = E
$$
**例4**

设字母表∑＝{a,b}，设计一个文法，描述语言 L={a$b^n$a |  n≥0}
$$
G =（\{A,B\}，\{a,b\}，P，A）\\\\
P=\{A→aBa,B→ \epsilon|Bb\}
$$

### 语言形式定义

**直接推导**：令 G 是一文法，一步推导 => 表示用某一规则的右部替换其左部。如果有 xAy => xαy，仅当 A→α 是 G 的一个规则（产生式），且 x、y ∈ ($V_T$∪$V_N$)*，称 xAy 直接推出 xαy。
$$
【例】设有文法G[S] = (\{S\},\{0,1\},P,S)\\\\
其中P为S→01 | 0S1\\\\
则可直接推导出S=>01, \; S=>0S1,\;0S1=>0011,\;00S11=>000S111...
$$
**推导**：如果存在一个直接推导序列：$α_0$ => $α_1$ => … => $a_n$则称这个序列是从$α_0$ 到$α_n$ 的长度为 n 推导，记为$a_0$=>+（这个符号其实是+在=>这个符号上面，这里表示不出来，==下面这个符号都用=>+表示==） $α_n$
$$
【例】设有文法 G[E] = (\{E,T,F\}, \{i,+,*,(,)\}, P, E)\\\\
P=\{E → E + T | T\\\\
T → T * F | F\\\\
F → i | (E)\}\\\\
则对 i+i*i 有如下直接推导序列
	E=>E+T=>T+T=>F+T=>i+T\\\\
		=>i+T*F=>i+F*F	\\\\
		=>i+i*F=>i+i*i\\\\
所以E =>+\;\;\,\,\, i+i*i
$$
**广义推导**：$α_0$ =>*(这个符号其实是\*在=>这个符号的上面，这里表示不出来，==下面这个符号都用=>\*表示==)$α_n$ 表示从α0 出发，经过 0 步或多步可推导$α_n$,也就是说$α_0$ =>\*$α_n$ 意味着： $α_0$ =$α_n$ 或者$α_0$ =>+$α_n$ 

直接推导的长度为1，推导的长度大于等于1，广义推导的长度大于等于0

**句型与句子**：

设有文法 G[S]，如果S=>\*x, x∈($V_T$∪$V_N$)\*，则称符号串 x 为文法 G[S]的句型.
如果S==>\*x, x∈$V_T^*$，则称符号串 x 为文法 G[S]的句子。

```
【例】设有文法 G[S]:	S→01 | 0S1
有
	S =>*01		句型，又是句子
	S =>*0S1		句型
	S =>*00S11		句型
	S =>*000111		句型，又是句子
```

```
【例】设有文法G[E]:E → E+E | E*E |(E) | i
试证明符号串 (i*i+i) 是文法G[E]的一个句子
分析：只要证明符号串(i*i+i) 对文法G[E]存在一个推导，就可证明符号串(i*i+i) 是文法G[E]的一个句子。
因为
E=>(E)=>(E+E)=>(E*E+E)=>(i*E+E)=>(i*i+E)=>(i*i+i)
即有 E=>*(i*i+i)
所以符号串 (i*i+i) 是文法G[E]的一个句子。
```

**语言**：

文法 G[S] 产生的所有句子的集合称为文法 G 所定义的语言，记为 L(G[S]):L(G[S]) = { x | S=>+x 且 x∈$V_T^*$ }，由语言定义可知：
(1)当文法给定，语言也就确定；
(2)L(G) 是 $V_T^*$ 的子集。即属于$V_T^*$的符号串不一定属于L(G)

### 文法求语言示例

**例1**

设有文法G[S]:  S→01 | 0S1，求该文法所描述的语言

分析：问题归结为由识别符号 S 出发，将推导出什么样的句子，也就是说 L(G{S])是由一些什么样的符号串所组成的集合，找出其中的规律，用式子或自然语言描述出来。

$S=>0S1=>00S11=>000S111=>…=>0^{n－1}S1^{n－1}=>0^n1^n$
即S  >=+ $0^n1^n$
所以此文法定义的语言为 L(G[E]) = {$0^n1^n$ | n≥1}

**例2**

设有文法G[S]:  S→0S|1S|$\epsilon $求该文法所定义的语言
$$
该文法所确定的语言为
L(G[S]) = \{\epsilon,0,1,00,01,10,11,…\}
	   = \{ x | x∈\{0,1\}^* \}
$$
**例3**

设有文法G[A]:  A→yB,B→xB|x求该文法所定义的语言
$$
从开始符号 A 出发，我们可以推出如下句子：\\\\
		A => yB => yx\\\\
		A => yB => yxB =>yxx\\\\
		  ……\\\\
		A => yB => yxB => … => yx…x\\\\
归纳得出从 A 出发可推导出所有以 y 开头后跟一个或任意多个 x 得字符串，即\\\\
L(G[A]) = \{ yx^n | n≥1 \}\\\\
$$

### 规范推导和规范归约

文法所定义的任一句型和句子，都可以根据文法推导出来，但同一个句型(句子)可以通过不同的推导序列推导出来，这是因为在推导过程中所选择非终结符的次序无关。

```
【例】设有文法 G[N1]:N1 → N,N → ND | D,D → 0 | 1 | 2
该文法所定义的语言是由数字 0，1，2组成的所有无符号整数。符号串 12 是该文法的一个句子，它可以通过下列不同的推导序列推导出来：
(1)		N1 =>N=>ND=>N2=>D2=>12
(2)		N1 =>N=>ND=>DD=>1D=>12
(3)		N1 =>N=>ND=>DD=>D2=>12
```

为了使句子能按一种确定的推导序列来产生，以便对句子的结构进行确定性的分析。通常只考虑两种特殊推导：

* 最左推导是指对于一个推导序列中的每一步直接推导 α=>β，都对 α 中的最左非终结符进行替换。
* 最右推导是指对于一个推导序列中的每一步直接推导 α=>β，都对 α 中的最右非终结符进行替换。

最右推导也称为规范推导，用规范推导推导出的句型称为规范句型。每个句子都有规范推导，但对句型此结论并不成立。

```
【例】对文法 G[N]:N →N’, N’→D | N’D, D →0 | 1 | 2 | … | 9
N=>N’=>N’D=>N’8=>D8=>88	规范推导
N=>N’=>N’D=>DD=>8D=>88	不是规范推导
```

**归约**：推导的逆过程。归约是与推导相对的概念，推导是把句型中的非终结符用规则的一个右部来替换的过程，而归约是句型中的某个子串用一个非终结符来替换的过程.用  =>· （实际上·在=>这个符号上面，==下面均用=>·表示这个符号==）表示归约。

```
【例】设 A→α是文法 G 的一个规则，则有
	xAy => xαy
	xαy  =>· xAy
```

```
【例】设有文法 G[S]:S→AB, A→A0 | 1B, B→0 | S1
请给出句子 101001 的最左和最右推导。
分析：
最右推导是指在推导过程中任何一步α=>β(α和β都是句型)，都是对α中的最右非终结符进行替换。
S=>AB=>AS1=>AAB1=>AA01=>A1B01=>A1001=>1B1001=>101001
最左推导是指在推导过程中任何一步α=>β(α和β都是句型)，都是对α中的最左非终结符进行替换。
S=>AB=>1BB=>10B=>10S1=>10AB1=>101BB1=>1010B1=>101001
```

规范推导的逆过程，称为最左归约，也称为规范归约。

```
【例】	文法G[N1]=N1 → N, N → ND | D,	D → 0 | 1 | 2
规范推导
	N1 =>N=>ND=>N2=>D2=>12
则有规范归约
	12=>·D2=>·N2=>·ND=>·N=>·N1 
```

### 递归规则与文法的递归性

**递归规则**：所谓递归规则，是指在规则的左部和右部具有相同的非终结符的规则。

```
如果文法中有规则 A→A... 	称为规则左递归
如果文法中有规则 A→...A 	称为规则右递归
如果文法中有规则 A→...A... 称为规则递归
```

**文法的递归性**：文法的递归性，是指对文法中任一非终结符，若能建立一个推导过程，在推导所得的符号串中又出现了该非终结符本身，则文法是递归的，否则是无递归性的。

```
若文法中有推导 A =>+ A... 	称为文法左递归
若文法中有推导 A =>+ ...A.. 	称为文法右递归
若文法中有推导 A =>+ ...A... 	称为文法递归
```

**文法中使用递归规则，使得能用有限的规则去定义无穷集合的语言。**

```
文法中有如下规则：
	U →Vx
	V →Uy | z
显然规则都不是递归规则，
但	U =>+ Uyx，则该文法是左递归的。
```

```
考虑文法 G[A]:
	A → aB | bB
	B → a | b
该文法无递归性，由它描述的语言是有穷的。L(G[A]) = {aa,ab,ba,bb}
```

$$
考虑文法 G[N1]:N1 → N, N → ND | D, D → 0 | 1 | 2\\\\
分析:该文法有直接左递归规则 N→ND，则称该文法为左递归文法或称文法左递归。\\\\
L(G[N1]) = \{x | x∈\{0,1,2\}^+\}
$$

* 文法中使用了递归规则，使得可用有限的规则去刻画无穷集合的语言。
* 若不用递归规则来定义文法，需要用无穷多条规则去表示无穷集合的语言
* 当一个语言是无穷集合时，则定义该语言的文法一定是递归的。
* 程序设计语言都是无穷集合，因此描述它们的文法必定是递归的。

### 短语、直接短语和句柄

令 G 是一个文法，S 是文法的开始符号，假定αβδ是文法 G 的一个句型，如果是
	S =>* αAδ 且 A  =>+ β
则称 β 是相对于非终结符 A 的句型 αβδ 的**短语**。
特别是，如果有
	S =>* αAδ 且 A  => β
则称β是**直接短语（简单短语）**。

短语是句型的一部分。
$$
考虑文法 G[N1]:N1 → N \\\\
			N → ND | D\\\\
			D → 0 | 1 | 2\\\\
对于句型 ND\\\\
(1)	N1 =>* N\\\\
	N1 =>* \; \epsilon N \epsilon \\\\
(2)	N =>+ ND\\\\
所以 ND 是句型 ND 的短语，并且是直接短语
$$
一个句型的最左直接短语称为该句型的**句柄**。
句柄特征：
(1)它是直接短语，即某规则右部
(2)它具有最左性。

**短语、直接短语和句柄都是针对某一句型的，特指句型中的哪些符号串能构成短语和直接短语，离开具体的句型来谈短语、直接短语和句柄是无意义的。**.

设有文法G[S]=({S,A,B},{a,b},P,S)	S →AB	A →Aa | bB	B →a|Sb 求句型 baSb 的全部短语、直接短语和句柄

根据短语定义，可以从句型的推导过程中找出其全部短语、直接短语和句柄。建立句型的推导过程：
	S=>AB=>bBB=>baB=>baSb	最左推导
	S=>AB=>ASb=>bBSb=>baSb	最右推导

<img src="https://i.loli.net/2020/02/20/qGT59Vw3EpthPfo.png" alt="image.png" style="zoom:50%;" />

### 语法树/推导树

对句型的推导过程给出一种图形表示，这种图形表示称为语法树，也称推导树。设文法 G=($V_N$，$V_T$，S，P)，对 G 的任何句型都能构造与之关联的、满足下列条件的一棵**语法树**。

* 每个结点都有一个标记，此标记是V＝$V_N$∪$V_T$∪{$\epsilon$\}中的一个符号。树
* 根的标记是文法的开始符号 S。
* 若某一结点至少有一个分支结点，则该结点上的标记一定是非终结符。
* 若 A 的结点有 k 个分支结点，其分支结点的标记分别为 A1,A2,…Ak,则 A→A1A2…Ak一定是G的一条规则

```
【例】设有文法 G[E] = ({E,T,F},{i,+,-,*,/,(,)},P,E)
其中P 为E → E+T | E-T | T;	T → T*F | T/F |F;  F → (E) | i
根据推导，画出句型 (i+i)*i-i 的语法树 
```

语法树的构造是从文法的开始符号出发，构造一个推导的过程，因为文法的每一个句型(句子)都存在一个推导，所以文法的每个句型(句子)都有一棵对应的语法树。

<img src="https://i.loli.net/2020/02/20/WEG4npyKZlvT6eM.png" alt="image.png" style="zoom: 50%;" />

<img src="https://i.loli.net/2020/02/20/VHLSercEM9ilFPk.png" alt="image.png" style="zoom:50%;" />

句型 (i+i)*i-i 的最左、最右推导得到的语法树完全相同，也就是说，一棵语法树表示一个句型的种种可能的(但未必是所有的)不同推导过程。

**子树**：语法树的子树是由某一个结点连同所有分支组成的部分。

**简单子树**：语法树的简单子树是指只有单层分支的子树。

根据子树的概念，句型的短语、直接短语和句柄的直观解释如下：

短语：子树的末端结点形成的符号串是相对于子树根的短语。
直接短语：简单子树的末端结点形成的符号串是相对于简单子树根的直接短语。
句柄：最左简单子树的末端结点形成的符号串是句柄。

因此可以由子树以及子树的末端节点直接看出短语、直接短语与句柄

<img src="https://i.loli.net/2020/02/20/RAP3BaMpucsqEIw.png" alt="image.png" style="zoom:50%;" />

### 文法的二义性

<img src="https://i.loli.net/2020/02/20/3mnRXUZlh24EWp7.png" alt="image.png" style="zoom:50%;" />

如果一个文法存在某个句子对应两棵不同的语法树，则称这个文法是二义的。也就是说，**若一个文法存在某个句子，它有两个不同的最左推导或有两个不同的最右推导，则称这个文法是二义的**

二义性的文法将给编译程序的执行带来问题。对于二义性文法的句子，当编译程序对它的结构进行语法分析时，就会产生两种甚至多种不同的理解。语法结构上的不确定性，必将导致语义处理上的不确定性。

**解决二义性问题**：构造一个等价的无二义性文法；即排除二义性的规则，改写原有的文法。

在改造文法的过程中，观察到推导步骤中的规律：靠前的推导，所用规则结合性弱；语法树上层次高；靠后的推导，所用规则结合性强，语法树上层次低。

也就是说，想要让一个规则结合性弱；就让它出现在推导序列前面（语法树的上层）；想要让一个规则结合性强；就让它出现在推导序列后面（语法树的下层），对于这样的强弱规律正好对应于运算的优先级规律，因此将运算符的优先顺序和结合规则，融合到原有文法中，可构造出无二义性文法

```
【例】对于文法 G<E>：E → E + E | E﹡E | (E) |i
按照终结符优先级的规律，可以构造出无二义性文法 G’[E] 如下：
		E → E + T | T	
        T → T * F | F		
        F → (E) | i		
```

改造之后的语法树就变为了：

<img src="https://i.loli.net/2020/02/20/byoqpSrj2v7YhLw.png" alt="image.png" style="zoom:50%;" />

### 文法种类

**2 型文法(上下文无关文法)**

若文法  G=($V_N$，$V_T$，S，P)中的每条规则 A → β，其中 A∈$V_N$，β∈($V_T$∪$V_N$)*，则称 G 是 2 型文法，2 型文法描述的语言是 2型语言

由定义可见，利用规则将 A 替换成 β 时，与 A 的上下文环境无关，即无需考虑 A 在上下文中出现的情况。故又称为上下文无关文法，相应的语言称为上下文无关语言。
通常定义程序设计语言的文法是上下文无关文法。

**3 型文法(正规文法)**

右线形文法：若文法G=($V_N$，$V_T$，S，P)中的每条规则A → αB 或 A → α，其中 A,B∈$V_N$，α∈$V_T$，则称 G 是右线形文法。
左线形文法：若文法G=($V_N$，$V_T$，S，P)中的每条规则A → Bα 或 A → α，其中 A,B∈$V_N$，α∈$V_T$，则称 G 是左线形文法。

右线形文法和左线形文法都称为 3 型文法或正规文法，3型文法描述的语言称为 3 型语言或正规语言。通常定义程序设计语言词法规则的文法是正规文法。

<img src="https://i.loli.net/2020/02/20/4jRoBQJX3ZYc1Uv.png" alt="image.png" style="zoom:50%;" />

## 词法分析

对源程序进行扫描产生单词符号，将源程序改造为单词符号串的中间程序，即输入源程序、输出单词符号。词法分析器(Lexical Analyzer)包括扫描器(Scanner)与执行词法分析的程序

**单词符号**是一个程序语言的基本语法符号。称作 token(记号) ，是具有独立意义的最小语法单位。将字符组合成记号与在一个英语句子中将字母构成单词并确定单词的含义很相像，此时的任务很像拼写。

程序语言的单词符号一般分为：

* 关键字：保留字
* 标识符：变量名、过程名等
* 常数：数字、字符串、布尔型等
* 运算符：+-/*等
* 界符：逗号，分号，/*、*/ 等

单词符号常常表示成二元式：（单词种别，单词符号的属性值）。**单词种别**是语法分析需要的信息，通常用整数编码。一个语言的单词符号如何分种，分成几种，怎样编码，是一个技术性的问题。它主要取决于处理上方便。

* 标识符一般统归为一种。
* 常数则按类型分种。
* 关键字可将其全体视为一种，也可以一字一种。采用一字一种的分法实际处理起来较为方便。
* 运算符可采用一符一种的分法，但也可以把具有一定共性的运算符视为一种。
* 界符一般用一符一种的分法。

**种别**通常定义为枚举类型的逻辑项。

```c
typedef enum {
   IF,ELSE,PLUS,NUM,ID,……
} TokenType;
```

**单词符号的属性值**是指单词符号的特性或特征，可以是标识符在符号表的入口地址、数值的二进制值等。

如果是一符一种的分法（如关键字，运算符等），词法分析器只给出其种别编码，不给出其属性值。
如果一个种别含有多个单词符号，那么对于它的每个单词符号，除了给出种别编码，还应给出属性值，以便把同一种类的单词区别开来。标识符属性值是自身的符号串；也可是在符号表的入口地址。常数自身值是常数的二进制数值。

**扫描器**必须计算每一个记号的若干属性，所以将所有的属性收集到一个单独构造的数据类型中是很有用的，这种数据类型称作记号记录(token record)。

```c
typedef struct {
    TokenType tokenval; 
    char* stringval;
    int numval;
} TokenRecord;
```

或作为一个联合

```c
typedef struct {
    TokenType tokenval; 
    unon { char* stringval;
          int numval; 
         } attribute;
} TokenRecord;
```

简而言之，扫描源程序，按照（单词种别，单词符号的属性值）这样的二元形式输出单词符号串

```
【例】试给出程序段 if (a>1) b = 100;输出的单词符号串。
假定基本字、运算符和界符都是一符一种，标识符自身的值是字符串，常数是二进制值。
(2,)	基本字 if
(29,)	左括号 (
(10,‘a’)	标识符 a
(23,)	大于号 >
(11,‘1’的二进制)	常数 1
(30，)	右括号 )
(10,‘b’)	标识符 b
(17,)	赋值号 =
(11,‘100’的二进制)	常数 100
(26,)	分号 ;
```

另一种表示可以为：

```
【例】考虑下述 C++ 代码段：while ( i >= j ) i--;	
假定基本字、运算符和界符都是一符一种，标识符自身的值是符号表的入口地址，常数是二进制值。
经词法分析器处理后，转换为如下的单词符号序列：
	( while ,- )
    ( (	   ,- )
    ( id    ,指向i的符号表表项的指针 )
    ( >=    ,- )
    ( id    ,指向j的符号表表项的指针 )
    ( )     ,- )
    ( id    ,指向i的符号表表项的指针 )
    ( --    ,- )
    ( ；    ,- )
```

词法分析作为一个独立的阶段（一遍），把源程序的字符序列翻译成单词符号序列存放于文件中，待语法分析程序工作时再从文件输入这些单词符号进行分析。结构更简单、清晰和条理化。有利于集中考虑词法分析一些细节问题。
词法分析作为一个子程序，每当语法分析器需要一个单词符号时就调用这个词法分析子程序。每一次调用，词法分析器就从输入字符串中识别出一个单词符号。

<img src="https://i.loli.net/2020/02/25/41f6pcJPzBsG9FY.png" alt="image.png" style="zoom: 50%;" />

通常，构造词法分析程序有两种方法：

* 手工方式：根据识别语言单词的状态转换图，使用某种高级语言。例如：用 C 语言直接编写词法分析程序
* 自动方式：利用词法分析程序的自动生成工具 LEX 自动生成词法分析程序。

### 词法分析手动设计

<img src="https://i.loli.net/2020/02/25/3vSDnsHCcVgh1wa.png" alt="image.png" style="zoom:50%;" />

**1.输入缓冲区、预处理**

词法分析器工作的第一步是输入源程序文本到输入缓冲区。
预处理工作：是将输入的源程序中的多余的空白符、跳格符、回车符、换行符等编辑性字符以及注释部分剔除掉，并将结果存入扫描缓冲区，方便单词符号的识别。

**2.扫描缓冲区**

* 为了保证单词符号不被扫描缓冲区边界打断，扫描缓冲区一般设计为如下一分为二的区域；
* 每次输入更新其一半空间的内容，使得词法分析器在最坏情况下识别单词符号的长度是扫描缓冲区长度的一半。因此也称配对缓冲区。
* 两个指示器
  * 起点指示器：新单词的首字符；
  * 搜索指示器：用于向前搜索以寻找单词的终点；
* 如果搜索指示器从单词起点出发搜索到半区的边缘，但未到单词的终点，则调用预处理程序，把后续的字符串装进另半区

<img src="https://i.loli.net/2020/02/25/l5jArHZwaeJ6iqo.png" alt="image.png" style="zoom: 50%;" />

**单词符号的识别：超前搜索**：源程序中的单词符号构成没有特殊的结尾，单词符号与单词符号之间在不引起可读性理解错误时也可以不必有空格作间隔，因此有时当单词符号的所有字符都已处理后，特别是当有单词符号是另一个单词符号的前缀子串时，词法分析器不能确定当前单词识别是否已结束，需要再超前搜索若干个字符后才能确定，返回识别出的单词，如果这时有多读进的字符，则需要回退处理。
例如 C 语言中的单词符号“>”、“>=”的识别就需要超前搜索。

不使用超前搜索的几种情况

* 规定所有基本字都是保留字；用户不能用它们作自己的标识符；基本字作为特殊的标识符来处理，使用保留字表；
* 如果基本字、标识符和常数(或标号)之间没有确定的运算符或界符作间隔，则必须使用一个空白符作间隔

**状态转换图**：状态转换图可用于识别（或接受）一定的字符串。大多数程序语言的单词符号都可以用转换图予以识别。

状态转换图是一张有限方向图，结点代表状态，用圆圈表示，状态之间用箭弧连结，箭弧上的标记(字符)代表射出结状态下可能出现的输入字符或字符类，一张转换图只包含有限个状态，其中有一个为初态，至少要有一个终态

状态转换图可用于识别(或接受)一定的字符串，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于 α，则称α被该状态转换图所识别(接受)

<img src="https://i.loli.net/2020/02/25/H2Ckr5hgYqBoI1t.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/25/5WuTEeIPlibdLqf.png" alt="image.png" style="zoom:50%;" />

【示例】

<img src="https://i.loli.net/2020/02/25/2rob5EIGFMJZd1q.png" alt="image.png" style="zoom:50%;" />

设计时假定：

* 基本字：所有基本字都是保留字，用户不得使用它们作为自己定义的标识符；
* 基本字作为一类特殊的标识符来处理，不再专设对应的转换图。但需要把关键字预先安排在一个表格，此表叫关键字表。当识别出一个标识符时，就去查关键字表，以确定它是否为一关键字。
* 若关键字、标识符和常数之间没有确定的运算符或界限府作间隔，则必须至少用一个空白符作间隔。

状态转换图实现时可以让每个状态结点对应一小段程序。

分支节点：

<img src="https://i.loli.net/2020/02/25/wxJPE1kXYjWlqOn.png" alt="image.png" style="zoom:50%;" />

循环状态节点

<img src="https://i.loli.net/2020/02/25/ReiQKSxy63aEhAd.png" alt="image.png" style="zoom:50%;" />

终态节点

<img src="https://i.loli.net/2020/02/25/bAl1eCoaWK8pNSF.png" alt="image.png" style="zoom:50%;" />

下面使用伪码来简单实现词法分析器

```
全局变量与过程
ch 字符变量，存放最新读入的源程序字符
strToken 字符数组，存放构成单词符号的字符串
GetChar 子程序过程，把下一个字符读入到 ch 中
GetBC 子程序过程，跳过空白符，直至 ch 中读入一非空白符
Concat 子程序，把ch中的字符连接到 strToken 
IsLetter和 IsDisgital 布尔函数，判断ch中字符是否为字母和数字
Reserve 整型函数，对于 strToken 中的字符串查找保留字表，若它是保留字则给出它的编码，否则回送0
Retract 子程序，把搜索指针回调一个字符位置
InsertId  整型函数，将strToken中的标识符插入符号表，返回符号表指针
InsertConst  整型函数，将strToken中的常数插入常数表，返回常数表指针
```

```fortran
int code, value;
strToken := “ ”;	/*置strToken为空串*/
GetChar();GetBC();
if (IsLetter())
begin
	while (IsLetter() or IsDigit())
	begin
		Concat(); GetChar(); 
	end
	Retract();
	code := Reserve();
	if (code = 0)
	begin
		value := InsertId(strToken);
		return ($ID, value);
	end
	else
		return (code, -);	
end
else if (IsDigit())
begin
	while (IsDigit())
	begin
		Concat( ); GetChar( );
	end
	Retract();
	value := InsertConst(strToken);
	return($INT, value);
end
else if (ch =‘=’) return ($ASSIGN, -);
else if (ch =‘+’) return ($PLUS, -);
else if (ch =‘*’)
begin
	GetChar();
	if (ch =‘*’) return ($POWER, -);
	Retract(); return ($STAR, -);
end
else if (ch =‘,’) return ($COMMA, -);
else if (ch =‘(’) return ($LPAR, -);
else if (ch =‘)’) return ($RPAR, -);
else ProcError( );		/* 错误处理*/
curState = 初态
GetChar();
while( stateTrans[curState][ch]有定义){
   //存在后继状态，读入、拼接
   Concat();
   //转换入下一状态，读入下一字符
   curState= stateTrans[curState][ch];
   if curState是终态 then 返回strToken中的单词
   GetChar( ); 
}
```

### 正规式与有限自动机

**正规式**：定义语言单词符号的一种方式

```
【例】定义标识符的正规式
字母(字母 | 数字)*
```

正规式和正规集的递归定义：

* ε 和 Φ 都是 ∑ 上的正规式，它们所表示的正规集分别为 {ε} 和 Φ；
* 任何 a∈∑, a 是 ∑ 上的一个正规式，它所表示的正规集为 {a}；
* 假定 e1 和 e2 都是 ∑ 上的正规式，它们所表示的正规集分别记为 L(e1)和 L(e2)，则：
  e1|e2 是正规式，表示的正规集为 L(e1)∪L(e2)
  e1e2  是正规式，表示的正规集为 L(e1)L(e2) （连接集）
  (e1)* 是正规式，表示的正规集为 (L(e1))*（闭包）
  优先级为闭包、连接积、或。

正规集可以用正规式表示，正规式是表示正规集一种方法，一个字符串集合是正规集当且仅当它能用正规式表示

正规式表示字符串的格式，正规式 r 完全由它所匹配的串集来定义。这个集合为由正规式生成的语言(language generated by the regular expression)，写作 L(r)，每个正规式可以看作是一个匹配模式。