## 概述

**编译程序**：将高级语言的源程序翻译成与之等价的低级语言的目标程序的这样一种程序

**源程序运行过程**：编译阶段+运行阶段或者编译阶段+汇编阶段+运行阶段

**解释程序**：以源程序作为输入，但不产生目标程序，解释一条执行一条

**汇编程序**：用于特定计算机上的汇编语言的翻译程序。有时编译器把汇编语言作为目标语言，然后再由汇编程序将它翻译成目标代码。

**连接程序**：将分别在不同的目标文件中编译或汇编的代码收集到一个可直接执行的文件中

**装入程序**：编译器、汇编程序或连接程序生成的代码还不能运行，装入程序处理所有的与指定的基地址有关的可重定位地址，并将修改后的指令和数据放在内存中适当的位置。

**预处理程序**：预处理程序是在真正的编译开始之前由编译器调用的独立程序。预处理程序可以删除注释、包含其它文件以及执行宏替代。

**源程序+初始数据→解释程序→计算结果**

**源程序→编译程序→初始数据+目标程序+运行系统子程序→计算结果**

### 编译过程

一般分为5个阶段：词法分析→语法分析→语义分析与中间代码产生→优化→目标代码生成

* 词法分析：按照语言的词法规则使用特定的工具将源程序转换成单词符号串
* 语法分析：按照语法规则使用上下文无关文法、确定的下推自动机将单词符号串转换为各类语法范畴 （层次结构分析）
* 语义分析与中间代码产生：按照语义规则使用属性文法将语法范畴进行初步翻译、产生中间代码（中间代码即独立于具体硬件的记号系统，四元式、三元式、逆波兰式等。）
* 优化：按照等价变换规则使用变换方法将中间代码变为更高效的中间代码
* 目标代码生成：将中间代码转换成依赖于机器的目标代码

[<img src="https://s2.ax1x.com/2020/02/11/1okNmF.png" alt="1okNmF.png" style="zoom:67%;" />](https://imgchr.com/i/1okNmF)

**表格管理程序**：登记源程序的各类信息和编译程序各阶段的进展情况，如符号表。

**出错处理程序**：发现并指出源程序中错误的性质和位置；自动校正错误

**遍**：对源程序或源程序的中间结果从头至尾扫描一次，并作有关的加工处理，生成新的中间结果或目标程序的处理过程称为一遍。可以把一个阶段分为若干遍，也可以把多个阶段合为一遍，通常有一遍和多遍编译程序。

**前端（front end）**：由与源语言有关但与目标机无关的部分组成。

**后端（back end）**：包括与目标机有关的部分。而一般不依赖于源语言，只与中间代码有关的编译阶段。

[<img src="https://s2.ax1x.com/2020/02/11/1oAVhR.md.png" alt="1oAVhR.md.png" style="zoom:67%;" />](https://imgchr.com/i/1oAVhR)

### 文法基础

程序语言是符号语言，即一个记号系统，它主要有语法、语义和语用等三方面定义。

**语法**：是对语言结构的定义（什么样的符号序列是合法的）。任何语言程序都可看成是一定字符集上的一字符串（有限序列），语法定义语言的词法和语法的形式规则。

* 字母表是一个有限的字符集，字符集中的字符是语言程序中可能出现的字符，它们是语言程序单词的组成部分。
* 词法规则定义了语言程序中单词符号的形成规则。即什么样的字符串是一个合法的单词。如标识符、数值常量、运算符等单词的构成规则。
* 语法规则定义了语言程序中语法单位的形成规则。一般语言的语法单位有表达式、语句、分程序、函数、过程和程序等。描述语法规则和进行语法分析的有效工具是上下文无关文法。

**语义**：描述语言的含义；定义语言的单词符号和语法单位的意义。目前编译程序中常用的语义分析方法是一种基于属性文法的语法制导翻译。即在语法分析的同时对其中识别出的语法单位进行语义的分析与翻译工作；在描述文法的同时为定义的语法范畴加上它们的属性计算规则，属性可以是语法范畴的类型、地址、取值、执行动作等信息。

**语用**：是从使用的角度去描述语言。定义程序设计技术和语言成分的使用方法，它使语言的基本概念与语言的外界（如数学概念或计算机的对象和操作）联系起来

**字母表(alphabet)**：字母表是元素的非空有穷集合，任何语言的字母表指出了该语言中允许出现的一切符号。

```
【例如】	∑ = {a,b,c}
∑是字母表，由 a,b,c 三个元素组成。
C 语言的字母表是字母、数字和若干专用符号组成。
```

**符号(symbol)**：字母表中的元素称为符号，或称为字符。

```
【例如】	∑ = {a,b,c}
a,b,c 是字母表 ∑ 中的符号。
```

**符号串（string）**:符号的有穷序列称为字符串。符号串总是建立在某个特定字母表上的且只能由字母表上的有穷多个符号组成。不包含任何符号的符号串，称为空符号串，用$\epsilon$(epsilon)表示

```
【例如】设有字母表 ∑ = {a,b,c}，
则有符号串 a,b,ab,ba,cba,abc,…
(a,b,ab,ba,cba,abc 等都是字母表∑上的符号串)
```

**符号串的连结 catenation**：设 x 和 y 是符号串，则串 xy 称为它们的连结。

```
【例如】设 x ＝ abc，y = 10a，
则 xy ＝ abc10a
则 yx ＝ 10aabc
```

特别，对任意一符号串 x 有：$\epsilon x=x \epsilon=x$

**集合的乘积 product**：设 A 和 B 是符号串的集合，则 A 和 B 的乘积定义为：AB = {xy | x ∈ A, y ∈ B}

```
【例如】设 A = {a,b}, B = {c,d}
则 AB ＝ {ac,ad,bc,bd}
```

**空集 Φ empty set**：Φ 表示不含任何元素的空集 { }

**符号串的幂运算 power**：设 x 是符号串，则 x 的幂运算定义为：
$$
x^0 ＝ \epsilon ;x^1 ＝ x;x^2 ＝ xx……x^n ＝ xx…x
$$

集合的幂运算同理，只不过$A^0=\{\epsilon\}$

**集合A的正闭包A+与闭包A**：设 A 是符号串的集合，则集合 A 的正闭包 A+ 和闭包 A* 定义为：
$$
A^+＝ A^1 U A^2 U A^3 U … U A^n U …\\\\
A^* ＝ A^0 U A^1 U A^2 U A^3 U … U A^n U … = \{ \epsilon \} U A^+
$$

$$
【例如】设 A = \{a,b\},则\\\\
	A^+ ＝ \{a,b,aa,ab,ba,bb,aaa,aab,…\}	\\\\
	A* ＝ \{\epsilon,a,b,aa,ab,ba,bb,aaa,aab,…\}
$$

### 形式语言和文法

**形式语言**：序列(字符串)的集合称为形式语言。每个形式语言都是某个字母表上按某种规则构成的所有符号串的集合；任何一个字母表上符号串的集合均可定义一个形式语言。

```
【例如】
C 语言是具有基本符号字母表上的符号串的集合。每个 C 语言程序是基本符号的符号串。
```

形式语言的描述有两种方法：

1. 当语言为有穷集合时，用枚举法来表示语言。

```
【例】设有字母表 A={a,b,c},则L1 ＝ {a,b,c},L2 ＝ {a,aa,ab,ac},L3 ＝ {c,cc}均表示字母表 A 上的一个形式语言。由于这三个语言均是有限符号串的集合，可以枚举出其全部句子来表示该语言。
```

2. 当语言为无穷集合时，需要设计文法来描述无穷集合的语言。

$$
【例】设有字母表 ∑=\{0,1\},\\\\
则∑^+ ＝ ∑^1 \bigcup∑2 \bigcup ∑3 \bigcup …  = 						\{0,1,00,10,11,01,000,100,…\}\\\\
用 A 表示 ∑^+，用式子 A→0 表示符号串 0∈A 或 A 生成符号串 0
则集合 A 可表示成：\\\\A→0;A→1;A→A0;A→A1
$$

显然由 A 生成的符号串属于 ∑+，这就是文法描述语言，它描述了无穷集合的语言。

**文法的形式定义**：

**规则**：规则也称产生式，它是一个符号与一个符号串的有序对（A,$\beta$），通常写做A→$\beta$（ 或 A::=$\beta$ ）

其中 A 是规则左部，是一个符号；$\beta$是规则右部，是一个符号串。→ 或 ::= 表示“定义为”或“生成”，意思是左部符号用右部符号串定义或左部符号生成右部符号串。规则的作用是告诉如何用规则中的符号串生成语言中的序列。一组规则规定了一个语言的语法结构。

非终结符：出现在产生式左部能派生出符号或符号串的那些符号，即每个非终结符表示一定符号串的集合。用大写字母表示或用尖括号把非终结符括起来。
终结符：是不属于非终结符的那些符号，它是组成语言的基本符号，是一个语言的不可再分的基本符号，只出现在产生式右部。通常用小写字母表示。

```
【例】产生式	A→A1 A→A0
	A 是非终结符，0、1 是终结符
```

**文法**：文法是规则的非空集合，是一个四元式G =（$V_N$，$V_T$，P，S），其中：

* $V_N$  是一个非空有限集，它的每个元素为非终结符号， 
* $V_T$  是一个非空有限集，它的每个元素为终结符号； $V_T$ ∩ $V_N$  = Φ 
* S 是一个非终结符号，称为开始符号或识别符号；开始符号 S 至少必须在某个产生式的左部出现一次。
* P 是一个产生式集合（有限），每个产生式的形式是P→α，其 P ∈ $V_N$ ， α ∈ ($V_T$∪$V_N$)*。

左部相同的产生式，如A→α1， A→α2， …， A→αn，可合并为一个，缩写为A→ α1|α2| … |αn 

### 设计文法示例

**例1**

设字母表∑＝{a,b},试设计文法，描述语言  L={$a^{2n}$，$b^{2n}$ |  n≥1}

分析：设计文法来描述一个语言，关键是设计一组规则生成语言中的符号串。设计语言的文法，必须分析这个语言是由怎样一些符号串组成，即首先分析语言中符号串的结构特征：

```
当 n=1		L = {aa,bb}
当 n=2		L = {aaaa,bbbb}
当 n=3		L = {aaaaaa,bbbbbb}
…
L = {aa,bb,aaaa,bbbb,aaaaaa,bbbbbb,…}
语言 L 是由偶数个 a，偶数个 b 这样的符号串组成的集合。
```

$$
文法1：G =（V_N，V_T，S，P），其中\\\\
	V_N = \{A, B, D\}\\\\
    V_T = \{a, b\}\\\\
    P = \{ A→aa | aaB | bb | bbD\\\\
    B→aa | aaB\\\\	
    D→bb | bbD \}\\\\
    S = A
$$

很显然，a,b是终结符，非终结符A定义完整L，需要终结符B、D来描述A，按照逻辑，该文法能描述语言L，此外，描述该语言的文法不是唯一的。
$$
文法2：G' =（V_N，V_T，S，P），其中\\\\
	V_N = \{A, B, D\}\\\\
    V_T = \{a, b\}\\\\
    P = \{ A→B|D\\\\
    B→aa | aBa\\\\	
    D→bb | bDb \}\\\\
    S = A
$$
G 和 G’ 是两个的文法，如果它们描述的语言相同，那么称 G 和 G’ 为等价文法。

**例2**

设计一个表示所有标识符的文法

分析：标识符的定义是字母或以字母开头的字母数字串（此处先不考虑大写字母）

显然，终结符是字母数字集合{a-z}∪{0-9}中的元素，标识符语言={字母*字母,字母\*数字}，因此设计文法
$$
用 I 表示标识符，L 代表字母，D 代表数字，定义标识符的文法为：G =（VN，VT，P，S）其中：\\\\
V_N = \{I,L,D\}\\\\
V_T = \{a,b,…,x,y,z,0,1,2,…,9\}\\\\
P = \{ I→L | IL |ID\\\\
L→ a | b | … | x | y | z\\\\
D→ 0 | 1 | … |9 \}\\\\
S = I
$$
**例3**

用文法定义一个含+、*、()的算术表达式。

分析：变量是表达式；若 E1 和 E2 是算术表达式，则 E1+E2，E1*E2，(E) 也是算术表达式。
$$
G =（V_N，V_T，P，S）其中：\\\\
V_N = \{ E \}\\\\	
V_T = \{ i,+,*,(,) \}\\\\
P = \{ E →i | E+E | E*E |(E) \}\\\\
S = E
$$
**例4**

设字母表∑＝{a,b}，设计一个文法，描述语言 L={a$b^n$a |  n≥0}
$$
G =（\{A,B\}，\{a,b\}，P，A）\\\\
P=\{A→aBa,B→ \epsilon|Bb\}
$$

### 语言形式定义

**直接推导**：令 G 是一文法，一步推导 => 表示用某一规则的右部替换其左部。如果有 xAy => xαy，仅当 A→α 是 G 的一个规则（产生式），且 x、y ∈ ($V_T$∪$V_N$)*，称 xAy 直接推出 xαy。
$$
【例】设有文法G[S] = (\{S\},\{0,1\},P,S)\\\\
其中P为S→01 | 0S1\\\\
则可直接推导出S=>01, \; S=>0S1,\;0S1=>0011,\;00S11=>000S111...
$$
**推导**：如果存在一个直接推导序列：$α_0$ => $α_1$ => … => $a_n$则称这个序列是从$α_0$ 到$α_n$ 的长度为 n 推导，记为$a_0$=>+（这个符号其实是+在=>这个符号上面，这里表示不出来，==下面这个符号都用=>+表示==） $α_n$
$$
【例】设有文法 G[E] = (\{E,T,F\}, \{i,+,*,(,)\}, P, E)\\\\
P=\{E → E + T | T\\\\
T → T * F | F\\\\
F → i | (E)\}\\\\
则对 i+i*i 有如下直接推导序列
	E=>E+T=>T+T=>F+T=>i+T\\\\
		=>i+T*F=>i+F*F	\\\\
		=>i+i*F=>i+i*i\\\\
所以E =>+\;\;\,\,\, i+i*i
$$
**广义推导**：$α_0$ =>*(这个符号其实是\*在=>这个符号的上面，这里表示不出来，==下面这个符号都用=>\*表示==)$α_n$ 表示从α0 出发，经过 0 步或多步可推导$α_n$,也就是说$α_0$ =>\*$α_n$ 意味着： $α_0$ =$α_n$ 或者$α_0$ =>+$α_n$ 

直接推导的长度为1，推导的长度大于等于1，广义推导的长度大于等于0

**句型与句子**：

设有文法 G[S]，如果S=>\*x, x∈($V_T$∪$V_N$)\*，则称符号串 x 为文法 G[S]的句型.
如果S==>\*x, x∈$V_T^*$，则称符号串 x 为文法 G[S]的句子。

```
【例】设有文法 G[S]:	S→01 | 0S1
有
	S =>*01		句型，又是句子
	S =>*0S1		句型
	S =>*00S11		句型
	S =>*000111		句型，又是句子
```

```
【例】设有文法G[E]:E → E+E | E*E |(E) | i
试证明符号串 (i*i+i) 是文法G[E]的一个句子
分析：只要证明符号串(i*i+i) 对文法G[E]存在一个推导，就可证明符号串(i*i+i) 是文法G[E]的一个句子。
因为
E=>(E)=>(E+E)=>(E*E+E)=>(i*E+E)=>(i*i+E)=>(i*i+i)
即有 E=>*(i*i+i)
所以符号串 (i*i+i) 是文法G[E]的一个句子。
```

**语言**：

文法 G[S] 产生的所有句子的集合称为文法 G 所定义的语言，记为 L(G[S]):L(G[S]) = { x | S=>+x 且 x∈$V_T^*$ }，由语言定义可知：
(1)当文法给定，语言也就确定；
(2)L(G) 是 $V_T^*$ 的子集。即属于$V_T^*$的符号串不一定属于L(G)

### 文法求语言示例

**例1**

设有文法G[S]:  S→01 | 0S1，求该文法所描述的语言

分析：问题归结为由识别符号 S 出发，将推导出什么样的句子，也就是说 L(G{S])是由一些什么样的符号串所组成的集合，找出其中的规律，用式子或自然语言描述出来。

$S=>0S1=>00S11=>000S111=>…=>0^{n－1}S1^{n－1}=>0^n1^n$
即S  >=+ $0^n1^n$
所以此文法定义的语言为 L(G[E]) = {$0^n1^n$ | n≥1}

**例2**

设有文法G[S]:  S→0S|1S|$\epsilon $求该文法所定义的语言
$$
该文法所确定的语言为
L(G[S]) = \{\epsilon,0,1,00,01,10,11,…\}
	   = \{ x | x∈\{0,1\}^* \}
$$
**例3**

设有文法G[A]:  A→yB,B→xB|x求该文法所定义的语言
$$
从开始符号 A 出发，我们可以推出如下句子：\\\\
		A => yB => yx\\\\
		A => yB => yxB =>yxx\\\\
		  ……\\\\
		A => yB => yxB => … => yx…x\\\\
归纳得出从 A 出发可推导出所有以 y 开头后跟一个或任意多个 x 得字符串，即\\\\
L(G[A]) = \{ yx^n | n≥1 \}\\\\
$$

### 规范推导和规范归约

文法所定义的任一句型和句子，都可以根据文法推导出来，但同一个句型(句子)可以通过不同的推导序列推导出来，这是因为在推导过程中所选择非终结符的次序无关。

```
【例】设有文法 G[N1]:N1 → N,N → ND | D,D → 0 | 1 | 2
该文法所定义的语言是由数字 0，1，2组成的所有无符号整数。符号串 12 是该文法的一个句子，它可以通过下列不同的推导序列推导出来：
(1)		N1 =>N=>ND=>N2=>D2=>12
(2)		N1 =>N=>ND=>DD=>1D=>12
(3)		N1 =>N=>ND=>DD=>D2=>12
```

为了使句子能按一种确定的推导序列来产生，以便对句子的结构进行确定性的分析。通常只考虑两种特殊推导：

* 最左推导是指对于一个推导序列中的每一步直接推导 α=>β，都对 α 中的最左非终结符进行替换。
* 最右推导是指对于一个推导序列中的每一步直接推导 α=>β，都对 α 中的最右非终结符进行替换。

最右推导也称为规范推导，用规范推导推导出的句型称为规范句型。每个句子都有规范推导，但对句型此结论并不成立。

```
【例】对文法 G[N]:N →N’, N’→D | N’D, D →0 | 1 | 2 | … | 9
N=>N’=>N’D=>N’8=>D8=>88	规范推导
N=>N’=>N’D=>DD=>8D=>88	不是规范推导
```

**归约**：推导的逆过程。归约是与推导相对的概念，推导是把句型中的非终结符用规则的一个右部来替换的过程，而归约是句型中的某个子串用一个非终结符来替换的过程.用  =>· （实际上·在=>这个符号上面，==下面均用=>·表示这个符号==）表示归约。

```
【例】设 A→α是文法 G 的一个规则，则有
	xAy => xαy
	xαy  =>· xAy
```

```
【例】设有文法 G[S]:S→AB, A→A0 | 1B, B→0 | S1
请给出句子 101001 的最左和最右推导。
分析：
最右推导是指在推导过程中任何一步α=>β(α和β都是句型)，都是对α中的最右非终结符进行替换。
S=>AB=>AS1=>AAB1=>AA01=>A1B01=>A1001=>1B1001=>101001
最左推导是指在推导过程中任何一步α=>β(α和β都是句型)，都是对α中的最左非终结符进行替换。
S=>AB=>1BB=>10B=>10S1=>10AB1=>101BB1=>1010B1=>101001
```

规范推导的逆过程，称为最左归约，也称为规范归约。

```
【例】	文法G[N1]=N1 → N, N → ND | D,	D → 0 | 1 | 2
规范推导
	N1 =>N=>ND=>N2=>D2=>12
则有规范归约
	12=>·D2=>·N2=>·ND=>·N=>·N1 
```

### 递归规则与文法的递归性

**递归规则**：所谓递归规则，是指在规则的左部和右部具有相同的非终结符的规则。

```
如果文法中有规则 A→A... 	称为规则左递归
如果文法中有规则 A→...A 	称为规则右递归
如果文法中有规则 A→...A... 称为规则递归
```

**文法的递归性**：文法的递归性，是指对文法中任一非终结符，若能建立一个推导过程，在推导所得的符号串中又出现了该非终结符本身，则文法是递归的，否则是无递归性的。

```
若文法中有推导 A =>+ A... 	称为文法左递归
若文法中有推导 A =>+ ...A.. 	称为文法右递归
若文法中有推导 A =>+ ...A... 	称为文法递归
```

**文法中使用递归规则，使得能用有限的规则去定义无穷集合的语言。**

```
文法中有如下规则：
	U →Vx
	V →Uy | z
显然规则都不是递归规则，
但	U =>+ Uyx，则该文法是左递归的。
```

```
考虑文法 G[A]:
	A → aB | bB
	B → a | b
该文法无递归性，由它描述的语言是有穷的。L(G[A]) = {aa,ab,ba,bb}
```

$$
考虑文法 G[N1]:N1 → N, N → ND | D, D → 0 | 1 | 2\\\\
分析:该文法有直接左递归规则 N→ND，则称该文法为左递归文法或称文法左递归。\\\\
L(G[N1]) = \{x | x∈\{0,1,2\}^+\}
$$

* 文法中使用了递归规则，使得可用有限的规则去刻画无穷集合的语言。
* 若不用递归规则来定义文法，需要用无穷多条规则去表示无穷集合的语言
* 当一个语言是无穷集合时，则定义该语言的文法一定是递归的。
* 程序设计语言都是无穷集合，因此描述它们的文法必定是递归的。

### 短语、直接短语和句柄

令 G 是一个文法，S 是文法的开始符号，假定αβδ是文法 G 的一个句型，如果是
	S =>* αAδ 且 A  =>+ β
则称 β 是相对于非终结符 A 的句型 αβδ 的**短语**。
特别是，如果有
	S =>* αAδ 且 A  => β
则称β是**直接短语（简单短语）**。

短语是句型的一部分。
$$
考虑文法 G[N1]:N1 → N \\\\
			N → ND | D\\\\
			D → 0 | 1 | 2\\\\
对于句型 ND\\\\
(1)	N1 =>* N\\\\
	N1 =>* \; \epsilon N \epsilon \\\\
(2)	N =>+ ND\\\\
所以 ND 是句型 ND 的短语，并且是直接短语
$$
一个句型的最左直接短语称为该句型的**句柄**。
句柄特征：
(1)它是直接短语，即某规则右部
(2)它具有最左性。

**短语、直接短语和句柄都是针对某一句型的，特指句型中的哪些符号串能构成短语和直接短语，离开具体的句型来谈短语、直接短语和句柄是无意义的。**.

设有文法G[S]=({S,A,B},{a,b},P,S)	S →AB	A →Aa | bB	B →a|Sb 求句型 baSb 的全部短语、直接短语和句柄

根据短语定义，可以从句型的推导过程中找出其全部短语、直接短语和句柄。建立句型的推导过程：
	S=>AB=>bBB=>baB=>baSb	最左推导
	S=>AB=>ASb=>bBSb=>baSb	最右推导

<img src="https://i.loli.net/2020/02/20/qGT59Vw3EpthPfo.png" alt="image.png" style="zoom:50%;" />

### 语法树/推导树

对句型的推导过程给出一种图形表示，这种图形表示称为语法树，也称推导树。设文法 G=($V_N$，$V_T$，S，P)，对 G 的任何句型都能构造与之关联的、满足下列条件的一棵**语法树**。

* 每个结点都有一个标记，此标记是V＝$V_N$∪$V_T$∪{$\epsilon$\}中的一个符号。树
* 根的标记是文法的开始符号 S。
* 若某一结点至少有一个分支结点，则该结点上的标记一定是非终结符。
* 若 A 的结点有 k 个分支结点，其分支结点的标记分别为 A1,A2,…Ak,则 A→A1A2…Ak一定是G的一条规则

```
【例】设有文法 G[E] = ({E,T,F},{i,+,-,*,/,(,)},P,E)
其中P 为E → E+T | E-T | T;	T → T*F | T/F |F;  F → (E) | i
根据推导，画出句型 (i+i)*i-i 的语法树 
```

语法树的构造是从文法的开始符号出发，构造一个推导的过程，因为文法的每一个句型(句子)都存在一个推导，所以文法的每个句型(句子)都有一棵对应的语法树。

<img src="https://i.loli.net/2020/02/20/WEG4npyKZlvT6eM.png" alt="image.png" style="zoom: 50%;" />

<img src="https://i.loli.net/2020/02/20/VHLSercEM9ilFPk.png" alt="image.png" style="zoom:50%;" />

句型 (i+i)*i-i 的最左、最右推导得到的语法树完全相同，也就是说，一棵语法树表示一个句型的种种可能的(但未必是所有的)不同推导过程。

**子树**：语法树的子树是由某一个结点连同所有分支组成的部分。

**简单子树**：语法树的简单子树是指只有单层分支的子树。

根据子树的概念，句型的短语、直接短语和句柄的直观解释如下：

短语：子树的末端结点形成的符号串是相对于子树根的短语。
直接短语：简单子树的末端结点形成的符号串是相对于简单子树根的直接短语。
句柄：最左简单子树的末端结点形成的符号串是句柄。

因此可以由子树以及子树的末端节点直接看出短语、直接短语与句柄

<img src="https://i.loli.net/2020/02/20/RAP3BaMpucsqEIw.png" alt="image.png" style="zoom:50%;" />

### 文法的二义性

<img src="https://i.loli.net/2020/02/20/3mnRXUZlh24EWp7.png" alt="image.png" style="zoom:50%;" />

如果一个文法存在某个句子对应两棵不同的语法树，则称这个文法是二义的。也就是说，**若一个文法存在某个句子，它有两个不同的最左推导或有两个不同的最右推导，则称这个文法是二义的**

二义性的文法将给编译程序的执行带来问题。对于二义性文法的句子，当编译程序对它的结构进行语法分析时，就会产生两种甚至多种不同的理解。语法结构上的不确定性，必将导致语义处理上的不确定性。

**解决二义性问题**：构造一个等价的无二义性文法；即排除二义性的规则，改写原有的文法。

在改造文法的过程中，观察到推导步骤中的规律：靠前的推导，所用规则结合性弱；语法树上层次高；靠后的推导，所用规则结合性强，语法树上层次低。

也就是说，想要让一个规则结合性弱；就让它出现在推导序列前面（语法树的上层）；想要让一个规则结合性强；就让它出现在推导序列后面（语法树的下层），对于这样的强弱规律正好对应于运算的优先级规律，因此将运算符的优先顺序和结合规则，融合到原有文法中，可构造出无二义性文法

```
【例】对于文法 G<E>：E → E + E | E﹡E | (E) |i
按照终结符优先级的规律，可以构造出无二义性文法 G’[E] 如下：
		E → E + T | T	
        T → T * F | F		
        F → (E) | i		
```

改造之后的语法树就变为了：

<img src="https://i.loli.net/2020/02/20/byoqpSrj2v7YhLw.png" alt="image.png" style="zoom:50%;" />

### 文法种类

**2 型文法(上下文无关文法)**

若文法  G=($V_N$，$V_T$，S，P)中的每条规则 A → β，其中 A∈$V_N$，β∈($V_T$∪$V_N$)*，则称 G 是 2 型文法，2 型文法描述的语言是 2型语言

由定义可见，利用规则将 A 替换成 β 时，与 A 的上下文环境无关，即无需考虑 A 在上下文中出现的情况。故又称为上下文无关文法，相应的语言称为上下文无关语言。
通常定义程序设计语言的文法是上下文无关文法。

**3 型文法(正规文法)**

右线形文法：若文法G=($V_N$，$V_T$，S，P)中的每条规则A → αB 或 A → α，其中 A,B∈$V_N$，α∈$V_T$，则称 G 是右线形文法。
左线形文法：若文法G=($V_N$，$V_T$，S，P)中的每条规则A → Bα 或 A → α，其中 A,B∈$V_N$，α∈$V_T$，则称 G 是左线形文法。

右线形文法和左线形文法都称为 3 型文法或正规文法，3型文法描述的语言称为 3 型语言或正规语言。通常定义程序设计语言词法规则的文法是正规文法。

<img src="https://i.loli.net/2020/02/20/4jRoBQJX3ZYc1Uv.png" alt="image.png" style="zoom:50%;" />

## 词法分析

对源程序进行扫描产生单词符号，将源程序改造为单词符号串的中间程序，即输入源程序、输出单词符号。词法分析器(Lexical Analyzer)包括扫描器(Scanner)与执行词法分析的程序

**单词符号**是一个程序语言的基本语法符号。称作 token(记号) ，是具有独立意义的最小语法单位。将字符组合成记号与在一个英语句子中将字母构成单词并确定单词的含义很相像，此时的任务很像拼写。

程序语言的单词符号一般分为：

* 关键字：保留字
* 标识符：变量名、过程名等
* 常数：数字、字符串、布尔型等
* 运算符：+-/*等
* 界符：逗号，分号，/*、*/ 等

单词符号常常表示成二元式：（单词种别，单词符号的属性值）。**单词种别**是语法分析需要的信息，通常用整数编码。一个语言的单词符号如何分种，分成几种，怎样编码，是一个技术性的问题。它主要取决于处理上方便。

* 标识符一般统归为一种。
* 常数则按类型分种。
* 关键字可将其全体视为一种，也可以一字一种。采用一字一种的分法实际处理起来较为方便。
* 运算符可采用一符一种的分法，但也可以把具有一定共性的运算符视为一种。
* 界符一般用一符一种的分法。

**种别**通常定义为枚举类型的逻辑项。

```c
typedef enum {
   IF,ELSE,PLUS,NUM,ID,……
} TokenType;
```

**单词符号的属性值**是指单词符号的特性或特征，可以是标识符在符号表的入口地址、数值的二进制值等。

如果是一符一种的分法（如关键字，运算符等），词法分析器只给出其种别编码，不给出其属性值。
如果一个种别含有多个单词符号，那么对于它的每个单词符号，除了给出种别编码，还应给出属性值，以便把同一种类的单词区别开来。标识符属性值是自身的符号串；也可是在符号表的入口地址。常数自身值是常数的二进制数值。

**扫描器**必须计算每一个记号的若干属性，所以将所有的属性收集到一个单独构造的数据类型中是很有用的，这种数据类型称作记号记录(token record)。

```c
typedef struct {
    TokenType tokenval; 
    char* stringval;
    int numval;
} TokenRecord;
```

或作为一个联合

```c
typedef struct {
    TokenType tokenval; 
    unon { char* stringval;
          int numval; 
         } attribute;
} TokenRecord;
```

简而言之，扫描源程序，按照（单词种别，单词符号的属性值）这样的二元形式输出单词符号串

```
【例】试给出程序段 if (a>1) b = 100;输出的单词符号串。
假定基本字、运算符和界符都是一符一种，标识符自身的值是字符串，常数是二进制值。
(2,)	基本字 if
(29,)	左括号 (
(10,‘a’)	标识符 a
(23,)	大于号 >
(11,‘1’的二进制)	常数 1
(30，)	右括号 )
(10,‘b’)	标识符 b
(17,)	赋值号 =
(11,‘100’的二进制)	常数 100
(26,)	分号 ;
```

另一种表示可以为：

```
【例】考虑下述 C++ 代码段：while ( i >= j ) i--;	
假定基本字、运算符和界符都是一符一种，标识符自身的值是符号表的入口地址，常数是二进制值。
经词法分析器处理后，转换为如下的单词符号序列：
	( while ,- )
    ( (	   ,- )
    ( id    ,指向i的符号表表项的指针 )
    ( >=    ,- )
    ( id    ,指向j的符号表表项的指针 )
    ( )     ,- )
    ( id    ,指向i的符号表表项的指针 )
    ( --    ,- )
    ( ；    ,- )
```

词法分析作为一个独立的阶段（一遍），把源程序的字符序列翻译成单词符号序列存放于文件中，待语法分析程序工作时再从文件输入这些单词符号进行分析。结构更简单、清晰和条理化。有利于集中考虑词法分析一些细节问题。
词法分析作为一个子程序，每当语法分析器需要一个单词符号时就调用这个词法分析子程序。每一次调用，词法分析器就从输入字符串中识别出一个单词符号。

<img src="https://i.loli.net/2020/02/25/41f6pcJPzBsG9FY.png" alt="image.png" style="zoom: 50%;" />

通常，构造词法分析程序有两种方法：

* 手工方式：根据识别语言单词的状态转换图，使用某种高级语言。例如：用 C 语言直接编写词法分析程序
* 自动方式：利用词法分析程序的自动生成工具 LEX 自动生成词法分析程序。

### 词法分析手动设计

<img src="https://i.loli.net/2020/02/25/3vSDnsHCcVgh1wa.png" alt="image.png" style="zoom:50%;" />

**1.输入缓冲区、预处理**

词法分析器工作的第一步是输入源程序文本到输入缓冲区。
预处理工作：是将输入的源程序中的多余的空白符、跳格符、回车符、换行符等编辑性字符以及注释部分剔除掉，并将结果存入扫描缓冲区，方便单词符号的识别。

**2.扫描缓冲区**

* 为了保证单词符号不被扫描缓冲区边界打断，扫描缓冲区一般设计为如下一分为二的区域；
* 每次输入更新其一半空间的内容，使得词法分析器在最坏情况下识别单词符号的长度是扫描缓冲区长度的一半。因此也称配对缓冲区。
* 两个指示器
  * 起点指示器：新单词的首字符；
  * 搜索指示器：用于向前搜索以寻找单词的终点；
* 如果搜索指示器从单词起点出发搜索到半区的边缘，但未到单词的终点，则调用预处理程序，把后续的字符串装进另半区

<img src="https://i.loli.net/2020/02/25/l5jArHZwaeJ6iqo.png" alt="image.png" style="zoom: 50%;" />

**单词符号的识别：超前搜索**：源程序中的单词符号构成没有特殊的结尾，单词符号与单词符号之间在不引起可读性理解错误时也可以不必有空格作间隔，因此有时当单词符号的所有字符都已处理后，特别是当有单词符号是另一个单词符号的前缀子串时，词法分析器不能确定当前单词识别是否已结束，需要再超前搜索若干个字符后才能确定，返回识别出的单词，如果这时有多读进的字符，则需要回退处理。
例如 C 语言中的单词符号“>”、“>=”的识别就需要超前搜索。

不使用超前搜索的几种情况

* 规定所有基本字都是保留字；用户不能用它们作自己的标识符；基本字作为特殊的标识符来处理，使用保留字表；
* 如果基本字、标识符和常数(或标号)之间没有确定的运算符或界符作间隔，则必须使用一个空白符作间隔

**状态转换图**：状态转换图可用于识别（或接受）一定的字符串。大多数程序语言的单词符号都可以用转换图予以识别。

状态转换图是一张有限方向图，结点代表状态，用圆圈表示，状态之间用箭弧连结，箭弧上的标记(字符)代表射出结状态下可能出现的输入字符或字符类，一张转换图只包含有限个状态，其中有一个为初态，至少要有一个终态

状态转换图可用于识别(或接受)一定的字符串，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于 α，则称α被该状态转换图所识别(接受)

<img src="https://i.loli.net/2020/02/25/H2Ckr5hgYqBoI1t.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/25/5WuTEeIPlibdLqf.png" alt="image.png" style="zoom:50%;" />

【示例】

<img src="https://i.loli.net/2020/02/25/2rob5EIGFMJZd1q.png" alt="image.png" style="zoom:50%;" />

设计时假定：

* 基本字：所有基本字都是保留字，用户不得使用它们作为自己定义的标识符；
* 基本字作为一类特殊的标识符来处理，不再专设对应的转换图。但需要把关键字预先安排在一个表格，此表叫关键字表。当识别出一个标识符时，就去查关键字表，以确定它是否为一关键字。
* 若关键字、标识符和常数之间没有确定的运算符或界限府作间隔，则必须至少用一个空白符作间隔。

状态转换图实现时可以让每个状态结点对应一小段程序。

分支节点：

<img src="https://i.loli.net/2020/02/25/wxJPE1kXYjWlqOn.png" alt="image.png" style="zoom:50%;" />

循环状态节点

<img src="https://i.loli.net/2020/02/25/ReiQKSxy63aEhAd.png" alt="image.png" style="zoom:50%;" />

终态节点

<img src="https://i.loli.net/2020/02/25/bAl1eCoaWK8pNSF.png" alt="image.png" style="zoom:50%;" />

下面使用伪码来简单实现词法分析器

```
全局变量与过程
ch 字符变量，存放最新读入的源程序字符
strToken 字符数组，存放构成单词符号的字符串
GetChar 子程序过程，把下一个字符读入到 ch 中
GetBC 子程序过程，跳过空白符，直至 ch 中读入一非空白符
Concat 子程序，把ch中的字符连接到 strToken 
IsLetter和 IsDisgital 布尔函数，判断ch中字符是否为字母和数字
Reserve 整型函数，对于 strToken 中的字符串查找保留字表，若它是保留字则给出它的编码，否则回送0
Retract 子程序，把搜索指针回调一个字符位置
InsertId  整型函数，将strToken中的标识符插入符号表，返回符号表指针
InsertConst  整型函数，将strToken中的常数插入常数表，返回常数表指针
```

```fortran
int code, value;
strToken := “ ”;	/*置strToken为空串*/
GetChar();GetBC();
if (IsLetter())
begin
	while (IsLetter() or IsDigit())
	begin
		Concat(); GetChar(); 
	end
	Retract();
	code := Reserve();
	if (code = 0)
	begin
		value := InsertId(strToken);
		return ($ID, value);
	end
	else
		return (code, -);	
end
else if (IsDigit())
begin
	while (IsDigit())
	begin
		Concat( ); GetChar( );
	end
	Retract();
	value := InsertConst(strToken);
	return($INT, value);
end
else if (ch =‘=’) return ($ASSIGN, -);
else if (ch =‘+’) return ($PLUS, -);
else if (ch =‘*’)
begin
	GetChar();
	if (ch =‘*’) return ($POWER, -);
	Retract(); return ($STAR, -);
end
else if (ch =‘,’) return ($COMMA, -);
else if (ch =‘(’) return ($LPAR, -);
else if (ch =‘)’) return ($RPAR, -);
else ProcError( );		/* 错误处理*/
curState = 初态
GetChar();
while( stateTrans[curState][ch]有定义){
   //存在后继状态，读入、拼接
   Concat();
   //转换入下一状态，读入下一字符
   curState= stateTrans[curState][ch];
   if curState是终态 then 返回strToken中的单词
   GetChar( ); 
}
```

### 正则式

**正则式**：定义语言单词符号的一种方式（或者叫正规式）

```
【例】定义标识符的正则式
字母(字母 | 数字)*
```

正则式和正则集的递归定义：

* ε 和 Φ 都是 ∑ 上的正则式，它们所表示的正则集分别为 {ε} 和 Φ；
* 任何 a∈∑, a 是 ∑ 上的一个正则式，它所表示的正则集为 {a}；
* 假定 e1 和 e2 都是 ∑ 上的正则式，它们所表示的正则集分别记为 L(e1)和 L(e2)，则：
  e1|e2 是正则式，表示的正则集为 L(e1)∪L(e2)（并集）
  e1e2  是正则式，表示的正则集为 L(e1)L(e2) （连接集）
  (e1)* 是正则式，表示的正规集为 (L(e1))*（闭包）
  优先级为闭包、连接积、或。

正则集可以用正则式表示，正则式是表示正则集一种方法，一个字符串集合是正则集当且仅当它能用正则式表示

正则式表示字符串的格式，正则式 r 完全由它所匹配的串集来定义。这个集合为由正则式生成的语言(language generated by the regular expression)，写作 L(r)，每个正则式可以看作是一个匹配模式。

```
【例】设∑={a,b,c},则aa*bb*cc* 是∑上的一个正则式
aa*bb*cc* 是∑上的一个正则式，它所表示的正则集是
L = {abc,aabc,abbc,abcc,aaabc,…}
  = {a^m b^n c^l | m,n,l ≥1}
```

```
【例】设程序语言字母表是键盘字符集合，则程序语言单词符号可用如下正则式定义
关键字	if | else | while | do
标识符	l (l | d)*
所整常数	dd*
关系运算符	< | <= | > | >= | <>
	其中 l 代表 a~z 中任一英文字母
    其中 d 代表 0~9 中任一数字
```

**正则式等价**

若两个正则式所表示的正则集相同，则认为二者等价。两个等价的正则式 R1 和 R2 记为 R1=R2。

```
【例】
	(a|b)* = (a*|b*)*
	b(ab)* = (ba)* b
```

**正则式扩展**

正则式 r 的一个或多个重复，写作 r+
. 表示与任意字符匹配。
用方括号和一个连字符表示字符的范围，如[0-9]，[a-z]，[a-zA-Z]。这种表示法还可以用作表示单个的解，如a|b|c 可写成[abc]

不在给定集合中的任意字符用 ”~”，如正规式 ~a 表示字母表中非 a 字符 
可选的子表达式r？表示由 r 匹配的串是可选的（0个或1个）。如natural = [0-9]+，signedNatural = (+|-)? Natural

### 正则文法与正则式

正则文法与正则式都是描述正规集的工具。

对任意一个正则文法，存在定义同一语言的正则式；反之，对每个正则式存在一个生成同一语言的正则文法。

**正则文法到正则式的转换**

将正则文法中的每个非终结符表示成关于它的正则式方程，获得一个联立方程组。依照求解规则：

**若 x = αx |β(或x = αx+β)，则解为x = α\*β**

**若 x = xα | β(或x = xα+β)，则解为x = βα\***

以及正规式的分配率、交换率和结合率求关于文法开始符号的正规式方程组的解。
这个解是关于文法开始符号 S 的一个正则式。上述两个规则较为重要，将递归的x消为α的闭包

【例1】
$$
【例】设有正规文法Ｇ：\\\\
	Z→0A\\\\
	A→0A|0B\\\\
	B→1A|\epsilon	\\\\试给出该文法生成语言的正规式
$$

```
首先给出相应的正规式方程组（+代替|）
			Z = 0A			………(1)
			A = 0A+0B 			………(2)
			B = 1A+$\epsilon $			………(3)

将(3)代入(2)式中的 B 得
			A = 0A+01A+0		………(4)
对(4)利用分配率	A = (0+01)A+0		………(5)
对(5)使用规则得	A = (0+01)\*0		………(6)
将(6)代入(1)得	Z = 0(0+01)\*0
即正规文法G[Z]所生成语言的正规式是 0(0|01)\*0
```

【例2】

```
设有正规文法Ｇ：
	A→aB|bB 
	B→aC|a|b
	C→aB	
试给出该文法生成语言的正规式
同上述步骤
首先给出相应的正规式方程组（+代替|）
			A = aB+bB			………(1)
			B = aC+a+b 		………(2)
			C = aB			………(3)
将(3)代入(2)式中得
			B = aaB+a+b		………(4)
对(4)使用规则得	B = (aa)\*(a+b)		………(5)
将(5)代入(1)得	A = (a+b)(aa)\*(a+b)
即正规文法G[Z]所生成语言的正规式是 (a|b)(aa)*(a|b)
```

【例3】

```
设有正规文法Ｇ：
	Z→U0|V1
	U→Z1|1
	V→Z0|0	试给出该文法生成语言的正规式
首先给出相应的正规式方程组（+代替|）
			Z = U0+V1			………(1)
			U = Z1+1 			………(2)
			V = Z0+0			………(3)
将(2)(3)代入(1)式得
			Z = Z10+10+Z01+01	………(4)
			Z = Z(10+01)+10+01	………(4)
对(4)使用规则得Z = (10+01)(10+01)*
即正规文法G[Z]所生成语言的正规式是 (10|01)(10|01)*

```

【例4】

```
已知描述“标识符”单词符号的正规文法
	<标识符> →l | <标识符>l | <标识符>d
首先给出相应的正规式方程组（+代替|）
	S = l+Sl+Sd
	S = l+S(l+d)
使用规则得
	S = l(l+d)*
该文法的正规式是 
	l(l|d)*
```

**正规式到正规文法的转换**

字母表∑上的正规式到正规文法 G＝(VN,VT,P,S)的转换方法如下：

1. 令 VT = ∑
2. 对任意正规式 R 选择一个非终结符 Z，生成规则 Z→R，并令 S＝Z；
3. 若 a 和 b 都是正规式，对形如 A→ab 的规则转换成 A→aB 和 B→b两规则，其中 B 是新增的非终结符；
4. 在已转换的文法中，将形如 A→a*b 的规则进一步转换成 A →aA | b；
5. 不断利用规则(3)和(4)进行转换，直到每条规则最多含有一个终结符为止。

【例1】

```
将R = (a|b)(aa)*(a|b) 转换成相应的正规文法
令 A 是文法开始符号，根据规则(2)变换为
A → (a|b)(aa)*(a|b)
根据规则(3)变换为
A → (a|b)B
B → (aa)*(a|b)
根据规则(4)变换为（逆推，将*转变为|）
A → aB|bB
B → aaB|a|b（aaB中有两个a，要简化到只有一个终结符为止）
根据规则(3)变换为
A → aB|bB
B → aC|a|b
C → aB
```

【例2】

```
将描述标识符的正规式R=l(l|d)*转换成相应的正规文法
令 S 是文法开始符号，根据规则(2)变换为
S→l(l|d)*
根据规则(3)变换为
S→lA 
A→(l|d)*
根据规则(4)变换为
S→lA
A→(l|d)A |ε
进一步变换为
S→lA
A→lA|dA|ε（消除ε）
进一步变换为
S→l|lA
A→l|d|lA|dA
```

### 有穷自动机

有穷自动机是具有离散输入与输出系统的一种抽象数学模型。有穷自动机有“确定的”和“非确定的”两类。确定的有穷自动机 和 非确定的有穷自动机都能准确地识别正规集。

### 确定有穷自动机(DFA) 

一个确定有穷自动机 DFA M 是一个五元式：M=( Q, ∑, f, S, Z)	其中：
Q：有限状态集，它的每个元素称为一个状态。
∑：有穷字母表，它的每个元素称为一个输入字符。
F：状态转换函数，是从 Q×∑ 至 Q 的单值映射。f(qi, a) = qj	 (qi,qj ∈ Q，a ∈ ∑)表示：当现行状态为 qi、输入字符为 a 时，自动机将转换到下一状态 qj 。称 qj 为 qi 的一个后继。
S∈Q：是唯一的初态。
Z  $\subset $ Q：终态集（可空）。

```
【例】设DFA  M=({q0,q1,q2},{a,b},f,q0,{q2})
其中：
f(q0,a)= q1
f(q1,b)= q1
f(q0,b)= q2
f(q2,a)= q2
f(q1,a)= q1
f(q2,b)= q1
```

**状态转换矩阵、状态转换图**

一个 DFA 可用一个矩阵表示，该矩阵的行表示状态，列表示输入字符，矩阵元素表示 f(s, a) 的值。这个矩阵称为状态转换距阵，或称转换表。
一个 DFA 也可以用一张（确定的）状态转换图表示，假定 DFA M 含有 m 个状态 n 个输入字符，这个状态转换图则有 m 个结点，每个结点最多有 n 条箭弧射出和别的状态相连，同一结点射出的每条箭弧用 ∑ 中的一个不同的输入字符作标记，整张图含有唯一一个初态结点和若干个（可以是0个）终态结点。

<img src="https://i.loli.net/2020/02/27/zBDPQbRLChoaTnH.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/27/dXA5sFqZVTlhx7e.png" alt="image.png" style="zoom:50%;" />

DFA M 识别的符号串：对于 ∑* 中的任何字 β，若存在一条从初态到某一终态结点的通路，且这条通路上的所有弧的标记符连接成的字等于 β ，则称β 可为 DFA M 所识别。若 M 的初态结同时又是终态结，则ε可为 M 所识别。

DFA M 所能识别的符号串的全体为其接受的语言，记为L(M)。 

结论：V  $ \subset $ ∑* 是正规的当且仅当存在  ∑ 上的自动机 M，使得 V=L（M）

**模拟 DFA 的算法**

输入：输入以文件结束符 eof 结尾的串 x；一个 DFA D，其开始状态为 s0，接受状态集合为 F。
输出：如果 D 接受 x，则回答 “yes”，否则回答“No”。
方法：把下列算法应用于输入字符串x。函数 move(s,c) 给出在状态 s 上遇到输入字符 c 时应该转换到的下一个状态。函数 getch() 返回输入串 x 的下一个字符。

```c
s=s0;
while ((c=getch())!=eof) {
	s=move(s,c);
	if (s is in F) return “yes”;
}
```

### 非确定有限自动机(NFA)

一个非确定有限自动机 M 是一个五元式：M=(Q,∑,S,Z,F)，其中：

Q：有限状态集
∑：有穷字母表
F：状态转换函数，是一个从 Q×∑* 至 S 的子集 S’ 的映射（多值映射）。即 
		f： Q×∑* →2Q    幂集
S $\subset $ Q：非空初态集
Z $\subset $ Q：终态集（可空）

一个 NFA 也可用一个矩阵表示，该矩阵的行表示状态，列表示输入字符，矩阵元素表示 f(s, a) 的值（状态集）。一个 NFA 也可以用一张状态转换图表示。

**NFA 和DFA的区别**

NFA可以有多个初态；
弧上的标记可以是∑*中的一个字(甚至可以是一个正规式)，而不一定是单个字符；
同一个字可能出现在同状态射出的多条弧上；
DFA是NFA的特例。

<img src="https://i.loli.net/2020/02/27/cQf8l9m6ZdyO5sT.png" alt="image.png" style="zoom:50%;" />

NFA M 识别的符号串，对于 ∑* 中的任何字 β，若存在一条从初态到某一终态结点的通路，且这条通路上的所有弧的标记符连接成的字（忽略ε弧）等于 β，则称β 可为 NFA M 所识别。若 M 的某些状态既是初态又是终态则空字 ε 被 M 所接受。

NFA M 所能识别的符号串的全体为其接受的语言，记为L(M)，如上例中NFA M’ 所识别的语言为L(M’) = b\*(b|ab)(bb)\*

由 NFA 的定义可知，同一个符号串  β 可由多条路来识别，DFA 是 NFA的特例，利用有穷自动机构造词法分析程序的方法是：

1. 从语言单词的描述中构造出 NFA；
2. 将 NFA 转化为 DFA；
3. 化简为状态最少化的 DFA；
4. 对 DFA 的每一个状态构造一个程序段将其转化为识别单词的词法分析程序。

### NFA 确定化为 DFA 的方法

NFA 的确定化是指对任给的 NFA，都能相应地构造一DFA，使它们接受相同的语言。

对于一个 NFA，由于状态转换函数 f 是一个多值函数，因此总存在一些状态 q，对于它们有

f(q,a)={q1, q2,…,qn}

它是 NFA 状态集合的一个子集，为了将 NFA 转换为 DFA，把状态集合{q1, q2,…,qn}看做一个状态 A，也就是说，从 NFA 构造 DFA 的基本思想是 DFA 的每一个状态代表 NFA 状态集合的某个子集，这个 DFA 使用它的状态去记录在 NFA 读入输入符号之后可能到达的所有状态的集合，称此构造方法为子集法。 

**状态集合 I 的 ε-闭包**

设 I 是 NFA N 的一个状态子集，ε-CLOSURE(I)定义如下：

```
若 s ∈ I，则 s ∈ ε-CLOSURE(I)
若 s ∈ I，那么从 s 出发经过任意条 ε 弧而能到达的任何状态 s’，都属于 ε-CLOSURE(I)
```

ε-CLOSURE(I)是一个从给定结点集合出发在转换图上搜索可达结点集合的过程。

```
将 I 中所有的状态压入栈 stack 中；
将 ε-CLOSURE(I)初始化为 I；
while 栈stack不空 do
begin
	将栈顶元素 t 弹出栈；
	for 每个这样的状态u:从t到u有一条标记为ε的边 do
		if u 不在 ε-CLOSURE(I) 中 do
		begin
		将 u 添加到 ε-CLOSURE(I)；
		将 u 压入栈 stack 中
		end 
end
```

<img src="https://i.loli.net/2020/02/27/m6YFtjOL1g2ENzT.png" alt="image.png" style="zoom:50%;" />

**从 NFA N=(Q,∑,F,S,Z)构造等价的DFA M=(Q’,∑,F’,S’,Z’)的方法**

首先将从初态 S 出发经过任意条 ε 弧所能到达的状态所组成的集合作为 M 的初态 S’，然后从 S’ 出发，经过对输入符号 a∈∑ 的状态转移所能到达的状态(包括读输入符号之前或之后所有可能的 ε 转移所能到达的状态)所组成的集合作为 M 的新状态，如此重复，直到不再有新的状态出现为止。 

```
置 DFA M 中的状态集合 Q’和 Z’为 ∅ 集。
给出 M 的初态 S’＝ ε-CLOSURE(S)，并把 S’ 置为未标记状态后加入到 Q’中。
初始时，ε-CLOSURE(S)是Q’中唯一的状态且未被标记；
while Q’中存在一个未标记的状态 T do
begin
标记 T；
  for 每个输入符号 a do
  begin 
  	U = ε-CLOSURE( f(T,a) );
    if  U 没有在 Q’中 then
    将 U 作为一个未标记的状态添加到 Q’中；
    f’(T,a) = U;
    end
end
```

【例】NFA确定化

<img src="https://i.loli.net/2020/02/27/E9vY28zXlUMAL5f.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/27/iUJ9Blt3vcI16d7.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/27/Vh8JAEugs2GMcTH.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/27/9z7uasbiflHXAYt.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/27/iBqpKAIREZMONjy.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/27/L62wcM7ubCBgixO.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/27/PGXHTArIOsZLuKj.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/27/WjT81nUveP6EH74.png" alt="image.png" style="zoom:50%;" />

### 有穷自动机与文法的相互转化

**右线性正规文法到有穷自动机的转换方法**

<img src="https://i.loli.net/2020/02/27/rVJk8tN153FCGxD.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/27/KRFQwvaU16SjGg2.png" alt="image.png" style="zoom:50%;" />

**左线性正规文法到有穷自动机的转换方法**

<img src="https://i.loli.net/2020/02/27/rpaUisgwzBvthC3.png" alt="image.png" style="zoom:50%;" />![image.png](https://i.loli.net/2020/02/27/REI3BfGa2hYoLmT.png)<img src="https://i.loli.net/2020/02/27/rpaUisgwzBvthC3.png" alt="image.png" style="zoom:50%;" />![image.png](https://i.loli.net/2020/02/27/REI3BfGa2hYoLmT.png)<img src="https://i.loli.net/2020/02/27/rpaUisgwzBvthC3.png" alt="image.png" style="zoom:50%;" />![image.png](https://i.loli.net/2020/02/27/REI3BfGa2hYoLmT.png)<img src="https://i.loli.net/2020/02/27/rpaUisgwzBvthC3.png" alt="image.png" style="zoom:50%;" />![image.png](https://i.loli.net/2020/02/27/REI3BfGa2hYoLmT.png)

<img src="https://i.loli.net/2020/02/27/REI3BfGa2hYoLmT.png" alt="image.png" style="zoom:50%;" />

**有穷自动机到正规文法的转换方法**

<img src="https://i.loli.net/2020/02/27/REI3BfGa2hYoLmT.png" alt="image.png" style="zoom: 50%;" />![image.png](https://i.loli.net/2020/02/27/496L1UpdTA57ilE.png)<img src="https://i.loli.net/2020/02/27/REI3BfGa2hYoLmT.png" alt="image.png" style="zoom: 50%;" />![image.png](https://i.loli.net/2020/02/27/496L1UpdTA57ilE.png)<img src="https://i.loli.net/2020/02/27/REI3BfGa2hYoLmT.png" alt="image.png" style="zoom: 50%;" />![image.png](https://i.loli.net/2020/02/27/496L1UpdTA57ilE.png)<img src="https://i.loli.net/2020/02/27/REI3BfGa2hYoLmT.png" alt="image.png" style="zoom: 50%;" />![image.png](https://i.loli.net/2020/02/27/496L1UpdTA57ilE.png)

<img src="https://i.loli.net/2020/02/27/REI3BfGa2hYoLmT.png" alt="image.png" style="zoom: 50%;" />![image.png](https://i.loli.net/2020/02/27/496L1UpdTA57ilE.png)<img src="https://i.loli.net/2020/02/27/REI3BfGa2hYoLmT.png" alt="image.png" style="zoom: 50%;" />![image.png](https://i.loli.net/2020/02/27/496L1UpdTA57ilE.png)

### 有穷自动机与正则表达式的相互转化

**由正则表达式构造NFA**

输入：字母表上的正规式 R

输出：识别语言 L(R) 的 NFA N

1.

<img src="https://i.loli.net/2020/02/27/ePDldyqRU49rBTS.png" alt="image.png" style="zoom:50%;" />

2.

<img src="https://i.loli.net/2020/02/27/eDqHMX8dmfUkLGQ.png" alt="image.png" style="zoom:50%;" />

3.

<img src="https://i.loli.net/2020/02/27/U1uPxcwX8fntQTL.png" alt="image.png" style="zoom:50%;" />

整个分裂过程中，所有新结点均采用不同的名字，保留 X，Y 为全图唯一初态结点和终态结点。

<img src="https://i.loli.net/2020/02/27/z6KBjrvuEiwPhdt.png" alt="image.png" style="zoom:50%;" />

**有穷自动机到正规式的转换**

逆推过程，增加新初态 X，与所有原初态用ε相连，增加新终态 Y，与所有原终态用ε相连，从而构成一个新的NFA M’，它只有一个初态 X 和一个终态 Y。在X 与 Y 之间进行弧合并。

<img src="https://i.loli.net/2020/02/27/WrRJy5vPLA7fIj1.png" alt="图片.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/27/A7pxGzBFfWYhv1y.png" alt="图片.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/27/dyUYkhQxT5bvz6m.png" alt="图片.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/02/27/xKUZHICaN16Di5m.png" alt="图片.png" style="zoom:50%;" />

### 实际设计

词法分析的任务就是扫描源文件，按照（单词符号（token），单词符号属性值）这样的二元形式输出单词符号串

**词法分析中要使用正则表达式来扫描整个文件以判别单词符号的种类**，单词符号按照种类进行划分，例如

```
TOKEN: {
<VOID : "void">
| <CHAR : "char">
| <SHORT : "short">
| <INT : "int">
| <LONG : "long">
| <STRUCT : "struct">
| <UNION : "union">
| <ENUM : "enum">
| <STATIC : "static">
| <EXTERN : "extern">
| <CONST : "const">
| <SIGNED : "signed">
| <UNSIGNED : "unsigned">
| <IF : "if">
| <ELSE : "else">
| <SWITCH : "switch">
| <CASE : "case">
| <DEFAULT_ : "default">
| <WHILE : "while">
| <DO : "do">
| <FOR : "for">
| <RETURN : "return">
| <BREAK : "break">
| <CONTINUE : "continue">
| <GOTO : "goto">
| <TYPEDEF : "typedef">
| <IMPORT : "import">
| <SIZEOF : "sizeof">
}
```

描述了关键字规则

```
TOKEN: {
<IDENTIFIER: ["a"-"z", "A"-"Z", "_"](["a"-"z", "A"-"Z", "_", "0"-"9"])*>
}
```

描述了标识符规则

**正则表达式会使用最长前缀匹配规则**，如遇到了voidFunction 会匹配voidFunction（标识符）而不是void （保留字）Function。 

同理，**描述数值规则**可使用（匹配10,16,8进制数值）

```
TOKEN: {
<INTEGER: ["1"-"9"] (["0"-"9"])* ("U")? ("L")?
| "0" ["x", "X"] (["0"-"9", "a"-"f", "A"-"F"])+ ("U")? ("L")?
| "0" (["0"-"7"])* ("U")? ("L")?
>
}
```

对于空白符或者注释来说要跳过，因此不使用TOKEN来描述，使用SPECIAL_TOKEN来**描述空白符**

```
SPECIAL_TOKEN: { <SPACES: ([" ", "\t", "\n", "\r", "\f"])+> }
```

[" ", "\t", "\n", "\r", "\f"] 表示 " "（空格）、"\t"（制表符）、"\n"（换行符）、"\r"（回车）、"\f"（换页符）之中的任意一个，后面加上“+”表示上述 5 种字符之一1 个或多个排列而成的字符串。

**描述行注释**

```
SPECIAL_TOKEN: {
<LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r\n" | "\r")?>
}
```

上述代码所描述的模式是以“//”开始，接着是换行符以外的字符，并以换行符结尾的字符串。简单来说，这里描述的是从“//”开始到换行符为止的字符串。文件的最后可能没有换行符，因此换行符是可以省略的。

**描述块注释**
首先要注意的是下列模式是无法正确地扫描块注释的。

```
SKIP { <"/*" (~[])* "*/"> }
```

按照最长匹配原则，可能会把代码也当做注释匹配进去，如

```
/* 本应只有这一行是注释…… */
int
main(int argc, char **argv)
{
printf("Hello, World!\n");
return 0; 
}/* 以状态 0 结束 */
```

如果这样写，那么直到注释的终结符为止都和模式“(~[])\*”匹配，
为了解决这个问题，需要进行如下修改，也就是进行**状态转移**

```
MORE: { <"/*"> : IN_BLOCK_COMMENT }
<IN_BLOCK_COMMENT> MORE: { <~[]> }
<IN_BLOCK_COMMENT> SKIP: { <"*/"> : DEFAULT }
```

上述例子中的 IN_BLOCK_COMMENT 是扫描的状态（state）。通过使用状态，可以实现只扫描代码的一部分。
让我们来讲解一下状态的使用方法。首先再看一下上述例子中的第 1 行。

```
SKIP: { <"/*"> : IN_BLOCK_COMMENT }
```

这样在规则定义中写下 { 模式：状态名 } 的话，就表示匹配模式后会迁移（transit）到对应的状态。上述例子中会迁移到名为 IN_BLOCK_COMMENT 的状态。
扫描器在迁移到某个状态后只会运行该状态专用的词法分析规则。也就是说，在上述例子中，除了IN_BLOCK_COMMENT 状态专用的规则之外，其他的规则将变得无效。要定义某状态下专用的规则，可以如下这样在 TOKEN 等命令前加上 < 状态名 >。

```
< 状态名 > TOKEN: {~}
< 状态名 > SKIP: {~}
< 状态名 > SPECIAL_TOKEN: {~}
```

DEFAULT 状态（DEFAULT state）表示扫描器在开始词法分析时的状态。没有特别指定状态的词法分析规则都会被视作 DEFAULT 状态。也就是说，至今为止所定义的保留字的扫描规则、标识符的规则以及行注释的规则实际上都属于 DEFAULT 状态。<"\*/">:DEFAULT 的意思是匹配模式 "*/" 的话就回到最初的状态。

MORE命令将表示为“仅匹配该规则的话扫描还没有结束”，也就是说，进入该状态的匹配必须表示为/\*...\*/这样的形式，否则就会报错

**扫描字符串字面量**

```
MORE: { <"\""> : IN_STRING } // 规则 1
<IN_STRING> MORE: {
<(~["\"", "\\", "\n", "\r"])+> // 规则 2
| <"\\" (["0"-"7"]){3}> // 规则 3
| <"\\" ~[]> // 规则 4
}
<IN_STRING> TOKEN: { <STRING: "\""> : DEFAULT } // 规则 5
```


首先，借助状态迁移可以用多个规则来描述 token。扫描到规则 1 的起始符“"”后迁移到IN_STRING 状态，只有规则 2、3、4 在该状态下是有效的。其次，除了最后的规则 5 之外，规则 1 ～ 4 都使用 MORE 命令将用多个规则扫描一个 token。也就是以“ ”包裹的任意字符