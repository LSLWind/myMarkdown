## 概述

紧接在词法分析和语法分析之后，编译程序要做的工作就是进行静态语义检查和翻译。
静态语义检查通常包括：类型检查，控制流检查，一致性检查，相关名字检查及名字的作用域分析等等。
虽然源程序可以直接翻译为目标语言代码，但是许多编译程序都采用了独立于机器的、复杂性介于源语言和机器语言之间的中间语言。
其好处便于进行与目标机无关的代码优化，也使得编译的前后端接口清晰，编译程序结构在逻辑上更简明。

<img src="H:\markdown文档\myMarkdown\基础知识\编译原理\六、中间代码产生.assets\image-20200602103118306.png" alt="image-20200602103118306" style="zoom:50%;" />

==即经过静态语义检查后将代码翻译成中间代码==

## 中间语言

编译程序所使用的中间代码有多种形式。常见的有：

* 后缀式（逆波兰记号）
* 图表示法
* 三地址代码（三元式，四元式，间接三元式）

### 后缀式（逆波兰式）

这种表示法将运算对象写在前面，把运算符号写在后面，比如把 a+b 写成 ab+，把 a\*b 写成 ab\*。

用这种表示法表示的表达式也称做后缀式。后缀表示法可以用于表示表达式，其最大的优点是易于计算机处理表达式。

```
常用的算法是：
使用一个栈；
自左至右扫描算术表达式（后缀表示）；
每扫描到运算对象，就把它推进栈；
扫描到运算符：
若该运算符是二目的，则对栈顶部的两个运算对象实施该运算，并将运算结果代替这两个运算对象而进栈；
若是一目运算符，则对栈顶元素执行该运算，并以运算结果代替该元素进栈；
最后的结果留在栈顶。
```

### 三地址代码

三地址代码语句的一般形式为
	X = a op b
其中，X、a 和 b 为变量字或编译时产生的临时变量，a、b还可以为常量；op 为运算符，如浮点算符和逻辑运算符等。

三地址代码的每条语句通常包含三个地址，两个用来存放运算对象，一个用来存放运算结果。在实际实现中，用户定义的名字将由指向符号表中该名字项的指针所取代。三地址码是语法树的线性表示。

由于三地址语句只含有一个运算符，因此多个运算符组成的表达式必须用三地址语句序列来表示。

```
如表达式 X=a*b+c/d 的三地址代码为：
(1)	T1 = a*b
(2)	T2 = c/d
(3)	T3 = T1 + T2
(4)	X = T3
```

**三地址语句的种类**

作为中间语言的三地址语句非常类似于汇编代码，它可以有符号标号和各种控制流语句。常用的三地址语句有以下几种：

* x = y op z 形式的赋值语句，其中 op 为二目的算术运算符或逻辑运算符。
* x = op y 形式的赋值语句，其中 op 为一目运算符，如一目减 uminus、逻辑非、移位运算符以及将定点数转换成浮点数的类型转换符。
* x := y 形式的赋值语句，将 y 的值赋给 x。
* 无条件转移语句 goto L，即下一个将被执行的语句是标号为 L 的语句。
* 条件转移语句 if x rop y goto L，其中 rop 为关系运算符，如 <、<=、==、!=、>、>= 等。若 x和 y满足关系 rop 就转去执行标号为 L 的语句，否则继续按顺序执行本语句的下一条语句。

**赋值语句生成三地址代码的S-属性文法定义。**

* 非终结符 S 有综合属性 S.code，它代表赋值语句的 S 的三地址代码。
* 非终结符 E 有两个属性：
  E.place 表示存放 E 值的名字；
  E.code 表示对 E 求值的三地址代码；
* 函数 newTemp 分配一个临时变量；
* 函数 gen 表示生成一个三地址代码；

<img src="H:\markdown文档\myMarkdown\基础知识\编译原理\六、中间代码产生.assets\image-20200608160649105.png" alt="image-20200608160649105" style="zoom:50%;" />

三地址语句可看成是中间代码的一种抽象形式。
具体实现用记录表示：四元式、三元式、间接三元式

#### 四元式

四元式是由四部分组成（四个域）：(i)(op，arg1，arg2，result)，其中：
op 为运算符；arg1、arg2 及 result 为指针，它们可指向有关名字在符号表中的登记项或一临时变量(也可空缺)。
约定：凡只需一个运算量的算符一律使用 arg1。

```
【例】表达式 –c 和赋值语句 X=a 的四元式
(i)(uminus, C,  , Ti)
(j)(assign, a,  , X)
```

```
【例】表达式 X = a*b+c/d 的四元式
(1)(*, a, b, T1)
(2)(/, c, d, T2)
(3)(+, T1, T2, T3)
(4)(=, T3, －, X)
```

```
【例】表达式 a = b* -c + b* -c 的四元式
(0)(uminus, c,  , T1)
(1)(*, b, T1, T2)
(2)(uminus, c,  , T3)
(3)(*, b, T3, T4)
(4)(+, T2, T4, T5)
(5)(=, T5,  , a)
```

**基本规则**

* 如果 op 是一个算术或逻辑运算符，则 result 总是一个新引进的临时变量，它用来存放运算结果。
* 四元式出现的顺序与表达式计值的顺序是一致的，
* 四元式之间的联系是通过临时变量实现的。
* 四元式由于其表示更接近程序设计的习惯而成为一种普遍采用的中间代码形式。

## 说明语句的翻译

程序中的每个名字(如变量名)都必须在使用之前进行说明，而说明语句的功能就是为编译程序说明源程序中的每一个名字及其性质。简单说明语句的一般形式是用一个基本字来定义某些名字的性质，如整型变量、实型变量等。

1. 为局部名字建立符号表条目
2. 为它分配存储单元
3. 符号表中包含名字的类型和分配给它的存储单元的相对地址等信息

* 程序设计语言中的说明语句旨在定义各种形式的有名实体，如常量、变量、数组、记录(结构)、过程、子程序等等，说明语句的种类也多，对象说明、变量说明、类型说明、过程说明等等。
* 编译程序把说明语句中定义的名字和性质登记在符号表中，用以检查名字的引用和说明是否一致。
* 许多说明语句的翻译并不生成相应的目标代码。
* 过程说明和动态数组的说明有相应的代码。 

### 举例：最简单的说明语句的语法描述

```
D -> integer namelist | real namelist
namelist -> namelist，id|id
即使用关键字 integer 和 real 定义一串名字的性质。对这种说明句的翻译是指在符号表中登录该名和性质。 
```

用上述文法来制导翻译(自下而上)存在着这样一个问题，只能在把所有的名字都归约成 namelist 后才能把它们的性质登记进符号表。这意味着 namelist 必须用一个队列(或栈)来保存所有这些名字。

**1.改造文法G[D]为G‘[D]：**

```
	D→D, id
	D→integer id
	D→real id
```

这样，就能把所说明的性质及时地告诉每个名字 id；或者说，每当读进一个标识符时就可以把它的性质登记到符号表中，而无须到最后再集中登记了。

* 定义函数 Fill(id,A)：功能是把名字 id 和性质 A 登录在符号表中；
* 定义一个语义变量 D.Att：用来传递相关名字的性质；因为一个性质说明(如integer)后可能有一系列名字。

**2.文法G‘[D]和相应的语义子程序**

<img src="H:\markdown文档\myMarkdown\基础知识\编译原理\六、中间代码产生.assets\image-20200608161935573.png" alt="image-20200608161935573" style="zoom:50%;" />

### 过程中的说明语句 (单层）

处理到过程的说明部分时，要为过程的局部名字安排存储（不是实际分配存储，而只是计算地址）。
对这些名字建立符号表项时，要记录名字和存储的相对地址。

* 为记录相对地址，可以使用一个变量 offset。
* 在处理过程的第一个说明之前，置 offset 为零。
* 每看到一个新的名字，则把名字连同 offset 的当前值登记到符号表，然后增加 offset。
* Offset 的增量由名字的类型决定，称为数据对象的宽度，用属性 WIDTH 表示。

**过程 enter(name, type, offset)**

功能：用来把名字name 填入到符号表中，并给出此名字的类型type 及在过程数据区中相对地址偏移量 offset。

**C语言：包括数组和指针变量**

<img src="H:\markdown文档\myMarkdown\基础知识\编译原理\六、中间代码产生.assets\image-20200608162204248.png" alt="image-20200608162204248" style="zoom:50%;" />



<img src="H:\markdown文档\myMarkdown\基础知识\编译原理\六、中间代码产生.assets\image-20200608162245576.png" alt="image-20200608162245576" style="zoom:50%;" />



<img src="H:\markdown文档\myMarkdown\基础知识\编译原理\六、中间代码产生.assets\image-20200608162308774.png" alt="image-20200608162308774" style="zoom:50%;" />

## 赋值语句的翻译

### 简单表达式及赋值语句的翻译

* 简单算术表达式：是一种仅含简单变量的算术表达式；
* 简单变量：是指普通变量和常数，但不含数组元素及结构引用等复合型数据结构。
* 简单算术表达式的计值顺序与四元式出现的顺序相同：因此很容易将其翻译成四元式形式，这些翻译方法稍加修改也可用于产生三元式或间接三元式。

翻译一般采取下列步骤：

1. 分析文法的特点。
2. 设置一系列语义变量，定义语义过程、语义函数。
3. 修改文法，写出每一规则的语义子程序。
4. 扩充 LR 分析栈，构造 LR 分析表

【例】

考虑以下文法

G[A]：A → i=E，E → E+E∣E*E∣−E∣(E)∣i

在此，非终结符 A 代表“赋值句”。文法G[A]虽然是一个二义文法，但通过确定运算符的结合性及规定运算符的优先级就可避免二义性的发生。为了实现由表达式到四元式的翻译，需要给文法加上语义子程序，以便在进行归约的同时执行对应的语义子程序。语义子程序所涉及的语义变量、语义过程及函数说明如下：

* 语义变量 E.place：E.place 表示存放 E 值的变量名在符号表中的入口地址或临时变量名的整数码。
* 语义函数 newtemp()：返回一个代表新临时变量的整数码；临时变量名按产生的顺序可设为 T1、T2、……。
* 语义过程 emit(T=arg1 op arg2) ：功能是产生一个四元式并填入四元式表中。有一个全局的四元式表。
* 语义函数 lookup(i.name)：功能是检查 i.name 是否出现在符号表中，符号表顺序：当前符号表、直接外层符号表、…、最外层符号表；是则返回 i.name 在符号表的入口指针，否则返回 NULL。

<img src="H:\markdown文档\myMarkdown\基础知识\编译原理\六、中间代码产生.assets\image-20200608163005722.png" alt="image-20200608163005722" style="zoom:50%;" />

【例】

<img src="H:\markdown文档\myMarkdown\基础知识\编译原理\六、中间代码产生.assets\image-20200608163136241.png" alt="image-20200608163136241" style="zoom:50%;" />



<img src="H:\markdown文档\myMarkdown\基础知识\编译原理\六、中间代码产生.assets\image-20200608163257013.png" alt="image-20200608163257013" style="zoom:50%;" />

### 含数组元素的赋值语句的翻译

数组是用来存储有规律或同类型数据的数据结构，数组中每一个元素在计算机中占有相同的存储空间 w（存储宽度）。

静态数组：如果在编译时就已知道一个数组存储空间，称该数组为静态数组。
动态数组：在运行时刻才能确定一个数组存储空间，称该数组为动态数组。

在表达式或赋值语句中若出现数组元素，则翻译时将牵涉到数组元素的地址计算。

数组在存储器中的存放方式决定：决定了数组元素的地址计算法；决定了产生什么样的中间代码

数组在存储器中的存放方式，两种常用方式：按行存放；按列存放

<img src="H:\markdown文档\myMarkdown\基础知识\编译原理\六、中间代码产生.assets\image-20200608171537233.png" alt="image-20200608171537233" style="zoom:50%;" />