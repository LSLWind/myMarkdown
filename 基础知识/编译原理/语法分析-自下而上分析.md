## 自下而上分析

### 基本原理

1. 将输入符号按从左到右顺序依次移入文法符号的栈栈中，边移入边分析；
2. 当栈顶符号串形成某条规则右部时就进行一次归约，即用该规则左部非终结符替换相应规则右部符号串。
3. 重复这一过程直到整个输入串分析完毕。
4. 最终若栈中剩下句子右界符“#”和文法的开始符号，则所分析的输入符号串是文法的正确句子。否则，就不是的正确句子，报告错误。

所有的自下而上分析方法都是按照移进-归约法原理。

**规约**

设 G =(VT,VN,S,P), α,β∈(VT∪VN)*, A→β∈P,αAw =>\* αβw
归约的过程是：已知 αβw 和产生式 A→β，用产生式A→β左部 A 替换αβw 中的β，得到符号串αAw。

从输入符号串出发，每次从被归约的句型中找到一个产生式的右部，用其左部替换之，得到新的句型，直至归约到文法的开始符号。
因为从左至右读入输入符号串，自然在被归约的句型中找最左边的某个产生式的右部（句柄）进行归约。

【例】文法G[A],A→aBcDe、B→b、B→Bb、D→d对输入串 abbcde 进行语法分析，检查该符号串是否是该文法的正确句子。

| **右句型** | **句柄**  | **归约规则** |
| ---------- | --------- | ------------ |
| abbcde     | **b**     | **B→b**      |
| aBbcde     | **Bb**    | **B→Bb**     |
| aBcde      | **d**     | **D→d**      |
| aBcDe      | **aBcDe** | **S→aBcDe**  |
| S          |           |              |

从例子中可以看出，一个句型中当含有多个子串可以匹配不同产生式的右部时，将有不同的归约过程

**规范规约**：在移进过程中，发现栈顶呈现句柄时就用相应的产生式的左部符号进行替换。

对输入串 abbcde 的最右推导过程是： A →aBcDe  → aBcde  → aBbcde  →abbcde。

该最右推导的逆过程就是就为规范规约，每次替换最左部最先发现的abbcde →aBbcde →aBcde →aBcDe →A

### 句柄

非形式地，一个符号串的“句柄”是和一个规则右部匹配的子串，而且把它归约到该规则左部的非终结符代表了最右推导逆过程的一步。

在很多情况下，匹配某个规则 A→β 右部的最左输入子串 β 不是句柄，因为用这个规则归约产生的串不能归约到开始符号。使用上述例子，对于串 aBbcde，b 是产生式 B→b 的右部，但 b 不是句柄。如果进行归约，得到 aBBcde，而 aBBcde 不能归约到 S。

* 句柄是某规则的右部符号串，假定规则：A → β 
* 句柄是 γ 一个子串，假定：γ = aβw
* 用 A 代替 β 得到 γ 最右推导的前一个右句型aAw ，那么，a后的 β 就是 aβw 的句柄。

### 移进-规约分析法的栈实现

“移进一归约”分析器使用一个栈和一个存放输入符号串 w 的缓冲器。
分析器的初始状态为:       

栈		输入		动作

\#		   w#
工作过程：自左至右把串 w 的符号一一移进栈里，一旦栈顶形成句柄时，就进行归约。这种归约可能持续多次，直至栈顶不再呈现句柄为止。然后，继续向栈里移进符号，重复这个过程

“移进”是指在栈顶还没有形成可归约串时，把输入串的一个符号移进符号栈；
“归约”是指发现栈顶已形成可归约串，对其进行归约；
“接受”是指宣布分析成功，表明输入串是文法合法的句子；
“出错处理”是指栈顶符号和要输入的符号在某种关系上出现矛盾，分析过程无法正常进行，通常此时要调用出错处理程序确定错误类型、校正错误，并使分析过程继续进行下去。 

**可归约串的出现必在栈顶**

| **步骤** | **分析栈** | **输入串**  | **动作**               |
| -------- | ---------- | ----------- | ---------------------- |
| **(0)**  | **#**      | **abbcde#** | **a** **进栈（移进）** |
| **(1)**  | **#a**     | **bbcde#**  | **b** **进栈（移进）** |
| **(2)**  | **#ab**    | **bcde#**   | 用B→b归约              |
| **(3)**  | **#aB**    | **bcde#**   | **b** **进栈（移进）** |
| **(4)**  | **#aBb**   | **cde#**    | 用B→Bb归约             |
| **(5)**  | **#aB**    | **cde#**    | **c** **进栈（移进）** |
| **(6)**  | **#aBc**   | **de#**     | **d** **进栈（移进）** |
| **(7)**  | **#aBcd**  | **e#**      | 用D→d归约              |
| **(8)**  | **#aBcD**  | **e#**      | **e** **进栈（移进）** |
| **(9)**  | **#aBcDe** | **#**       | 用A→aBcDe归约          |
| **(10)** | **#A**     | **#**       | **分析成功（接受）**   |

在分析过程中，当分析到第(4)步时，栈内符号串是 aBb，栈顶符号串 b 和 Bb 分别是规则 B→b 和 B→Bb 的右部，为什么此时知道栈顶符号串 Bb 是可归约串，而 b 不是可归约串呢？

存在多种不同的方法刻画“可归约串”，对“可归约串”不同定义形成不同的自下而上的分析方法。
规范归约分析法中：用句柄来刻画可归约串；
算符优先分析法中：用最左素短语来刻画可归约串；
根据识别“可归约串”不同方法，形成不同的自下而上的分析方法。简单优先分析法、LR分析法都是规范归约法，都是用句柄刻画“可归约串”，但识别“句柄”的方法不同：
简单优先分析法：根据文法符号之间的优先关系来确定栈顶符号串是否形成句柄；
LR分析法：根据历史、现实、展望三者信息来确定栈顶符号串是否形成句柄；

## 算符优先分析法

算符优先分析法是一种简单、直观、广为使用的自下而上语法分析方法，它是依据算术表达式的四则运算过程而设计的一种方法，也适用于对一般的高级语言程序的分析。

基本思想：
首先确定运算符（确切地说是终结符）之间的优先关系和结合性质
然后借助这种关系，比较相邻运算符之间的优先级来确定句型的可归约串，并进行归约。

算符优先分析过程虽然是自下而上归约过程，但它的可归约串未必是句柄，也就是说，算符优先分析过程不是一种规范归约。

```
【例】文法G[E]：E→E+E | E*E | (E) | id
这是一个二义性文法，对句子 id+id*id 有两种不同的规范归约，在规范过程中句型的句柄不唯一。
第一个规范归约过程
(1) id+id*id
(2) E+id*id
(3) E+E*id -- id是句柄
(4) E+E*E
(5) E+E
(6) E
第二个规范归约过程
(1) id+id*id
(2) E+id*id
(3) E+E*id -- E+E是句柄
(4) E*id
(5) E*E
(6) E
此现象的出现是因为没有定义运算符 + 和 * 的优先关系而引起的。在归约过程中起决定作用的是相邻两个终结符之间的优先关系。
```

### 优先关系矩阵

文法终结符号之间的优先关系可用一个矩阵来表示，矩阵的每一行每一列都是文法的终结符，矩阵元素是两终结符之间可能的优先关系。算符优先分析法就是借助优先关系矩阵寻找句型的可归约串。

算法优先分析法并不是对所有的文法都适合，它对文法有一定的要求，要求文法是算法优先文法，也就是说，只有当描述语言的文法是算法优先文法，才能采用算法优先分析法进行语法分析。

###  算符优先文法(OPG)

**算符文法的定义**
设有文法 G，若它的任一规则的右部都不含两个相邻（并列）的非终结符，即不含形如：
		U→…VW…	的规则，
则称该文法为算符文法，也称OG (Operator Grammar)文法。

**算符文法性质**

* 在算符文法中，任意句型都不含两个相邻的非终结符。
* 若 Ab 或 bA 出现在算符文法的句型y 中，则 y 中任何含 b 的短语必包含 A。(含 b 的短语必含 A，含 A 的短语不一定含 b。)

**定义任何两个终结符号之间的优先关系**
设 G 是一个算符文法，对于任何终结符 a、b，算法优先关系 <·、=·、·> 定义如下：

* a=·b ：当且仅当 G 中含有形如 P→…ab… 或 P→aQb… 的规则；
* a<·b ：当且仅当 G 中含有形如 P→…aR… 的产生式，而 R =>+ b…  或 R =>+ Qb… ；
* a·>b：当且仅当 G 中含有形如 P→…Rb… 的产生式，而 R =>+ …a 或 R =>+ …aQ；

**算法优先文法的定义**
设有一个不含ε-规则的算符文法 G，如果任何终结符对(a，b)至多只满足下述关系之一：
a =· b， a ·> b， a <· b；
则称 G 是一个算符优先文法，也称 OPG 文法。(OPG —Operator Precedence Grammar)

```
【例】文法G[E]：E→E+E | E*E | (E) | id
所有规则中都没有相邻的非终结符，所以它是算符文法 OG 文法。
由于 E → E+E 和 E =>+ E*E，所以有 + <· *
由于 E → E*E 和 E =>+ E+E，所以有 + ·> *
运算符 + 和 * 之间存在两种不同的优先关系，所以该文法不是算法优先文法 OPG.
文法 G[E]：	
E → E + T | T
T → T * F | F 
F → (E) | id
该算法是算法优先文法（OPG）
```

### 算符优先关系表的构造

对任意的文法非终结符 A，给出集合FIRSTVT(A)和LASTVT(A)的定义：
FIRSTVT(A)={a︱A=>+ a…或 A=>+ Ba…，a∈VT 而B∈VN } 
LASTVT(A)={a∣A=>+ …a 或 A=>+ …aB，a∈VT 而B∈VT } 

由上述定义，我们有：

若产生式右部是 …aA…，且 b∈FIRSTVT(A)，则必有优先关系： a <· b
若产生式右部是 …Ab…， 且 a∈LASTVT(A)，则必有优先关系： a ·> b 

对于算符优先文法，可以引入一个新的文法开始符号。
S’ → #S#
可以看成是句子的括号。

* 所以对 FirstVT(S)中的所有 b，	置 # <• b;
* 对 LastVT(S) 中的所有 a，	置 a •> #;
* 置 # =• #;

**构造优先关系表的算法**

```
为每一个非终结符 A 集合 FIRSTVT(A)和LASTVT(A);
由 FirstVT(A)和LastVT(A)集出发构造分析表;
对 FirstVT(S)中的所有 b，	置 # <• b;
对 LastVT(S) 中的所有 a，	置 a •> #;
置 # =• #;
画一个二维表 M，行下标和列下标分别都是所有的终结符，再加上“#”。在M(a,b)处填上 a 和 b 的关系（可能为空，表示 a 和 b 无关系）。

构造 FirstVT(A) 的规则：
若有规则 A→a... 或 A→Ba...，则 a∈FirstVT(A)
若 a∈FirstVT(B)，且有产生式 A→B...，则 a∈FirstVT(A)

构造 LastVT(A) 的规则：
若有产生式 A→...a 或 P→...aB,则 a∈LastVT(A)
若 a∈LastVT(B)，且有产生式 A→...B，则 a∈LastVT(A)

由FirstVT(A)和LastVT(A)集构造分析表算法：
for ( 每条产生式 A→x1x2…xn )
  for ( i=1; i<=n-1; i++ )
  { 
    if ((xi∈VT)&&(xi+1∈VT)) 置 xi =• xi+1;//...ab... a=b
    if ((i∈n-2)&&(xi∈VT)&&(xi+1∈VN)&&(xi+2∈VT))
	 置 xi =• xi+2;                        // ...aAb... a=b
    if (xi∈VT)&&(xi+1∈VN ))
	 for (任意 b∈FIRSTVT(xi+1)) 置 xi <• b;  //...aA... 
    if (xi∈VN)&&(xi+1∈VT))
	 for (任意 a∈LASTVT(xi)) 置 a •> xi+1;   //...Aa... 
  }
```

【例】表达式文法G[E]：
E→E + T | T
T→T * F | F
F→ (E)∣id
构造该文法的算符优先关系表。
对 E 求 FIRSTVT（E）和 LASTVT（E）:

|       | **FirstVT** | **LastVT** |
| ----- | ----------- | ---------- |
| **E** | {*,+,(,id}  | {*,+,),id} |
| **T** | {*,(,id}    | {*,),id}   |
| **F** | {(,id}      | {),id}     |

构造该文法的算符优先关系表。

按步骤构造如下：
(1)逐条扫描产生式，因有产生式F→(E)，则有（ =• ）。
(2)寻找终结符在左边，非终结符在右边的符号对有	

E→E+T		+T	则 + <• FirstVT(T)

T→T*F		*F	则 * <• FirstVT(F)

​	F→(E)		(E	则 ( <• FirstVT(E)

寻找非终结符在左边，终结符在右边的符号对有

E→E+T		E+	则 LastVT(E) •> + 

T→T\*F		T*	则 LastVT(T) •> *	

F→(E)		E)	则 LastVT(E) •> )

\# <• FIRSTVT(E)，   LASTVT(E) •> #，	# =• #。 

<img src="https://i.loli.net/2020/05/06/Y7slkEnAfOiIFZC.png" alt="image.png" style="zoom:50%;" />

### 算符优先分析算法的设计

素短语：是指这样的一个短语，它至少含有一个终结符，并且除它自身之外不再含有任何更小的素短语。
最左素短语：是指处于句型最左边的那个素短语。最左素短语是算符优先分析算法的可归约串。

【例】考虑表达式文法 G[E]的句型 T+T*F+id 的素短语和最左素短语。

T\*F 和 id 是素短语，T*F 是最左素短语
T 是句柄，但不是素短语

**识别句型最左素短语的方法**

一个算符优先文法 G 的一般句型可写成：
\#N1 a1 N2 a2••• Nn an Nn+1 #
其中 ai 是终结符，Ni 是可有可无的非终结符。
也就是说，在算符优先文法的一般句型中，任何两个终结符之间顶多只有一个非终结符。即任何句型都没有相邻的两个非终结符。

由最左素短语的定义，一个算符优先文法 G 的任何句型
\# N1 a1 N2 a2••• Nn an Nn+1 #
的最左素短语是满足下列条件的最左子串
	Ni ai Ni+1 ai+1••• Nj aj Nj+1：
		ai－1 <· ai
		ai  =· ai+1，...，aj－1 =· aj
		aj ·> aj+1
也就是说， Ni ai Ni+1 ai+1••• Nj aj Nj+1 已经和某个产生式的右端匹配，即已形成可归约串，可以对它进行归约。

```
【例】考虑表达式文法 G[E] 的句型 T+T*F+id 的最左素短语。
	# T +  T * F  +  id #	
	# N1 a1 N2 a2 N3  a3   a4  #
	# < +  < * >  + < id < #
        N2 a2 N3	是最左素短语
```

**算符优先分析算法**

最左素短语中的终结符具有相同的优先关系

最左素短语中的符号是当时最先要归约的串，其优先关系先于最左素短语之外的符号，所以使用一个用于存放文法符号的先进后出栈，并利用优先可以确定最左素短语是否已形成来决定分析器的动作。

* 如果当前栈顶的终结符 <· 或 =· 待输入符号，表示栈顶符号串未形成最左素短语，应该移进输入符号。
* 如果当前栈顶的终结符 ·> 输入符号，表示已找到最左素短语的尾，再从栈顶开始，按优先关系在栈内向左寻找最左素短语的头，然后归约最左素短语。
* 如果出现两个终结符之间不存在优先关系，则表示语法错误，进行出错处理。

我们使用一个符号栈 S，既用它寄存终结符，也用它寄存非终结符，用 k 代表符号栈 S 的使用深度。

```
k := 1；	S[k] :=‘#’；
REPEAT
把下一个输入符号读进 a 中；
IF  S[k]∈VT THEN j :=k  ELSE j :=k－1;
WHILE  S[j] ·> a  DO
BEGIN
	REPEAT
	Q :=S[j];
    IF S[j－1] ∈VT THEN  j :=j－1  ELSE  j :=j－2
    UNTIL  S[j] <· Q;
    把 S[j+1]...S[k] 归约成某个串 N;
    k := j+1;
    S[k] := N;
END OF WHILE;
IF S[j] <· a  OR  S[j] =· a  THEN
BEGIN
    k := k+1;
    S[k] :=a; 
END
ELSE  ERROR
UNTIL a =‘#’
```

### 优先函数的构造

在算符优先分析法中，文法终结符之间的优先关系是用矩阵表示的，这样需要大量的内存空间。
当文法有 n 个终结符时，就需要(n+1)2 个内存单元(包括#)。
实际实现中使用优先函数来代替优先矩阵表示优先关系，对具有 n 个终结符的文法，它只需 2(n+1) 个内存单元存放优先函数，可以节省大量存储空间。

**优先函数的定义**

把每个终结符 a 与两个自然数 f(a) 和 g(a) 相对应，使得：
若  a <· b  则   f(a) < g(b)    
若  a ·> b  则   f(a) > g(b)            
若  a =· b  则   f(a) = g(b)
函数 f 称为栈内优先函数(入栈优先函数)，函数 g 称为栈外优先函数(比较优先函数)

**构造优先函数的方法**

**逐次加一法(Floyd方法)**

```
确定初值，对所有终结符 a（包括#），
令f(a)＝f(b)＝0（也可为其它任意整数）。
对所有终结符 a 和 b
若  a ·> b  而 f(a)≤g(b)，则令 f(a)=g(b)+1
若  a <· b  而 f(a)≥g(b)，则令 g(b)=f(a)+1
若  a =· b  而 f(a)≠g(b)，则令f(a) = g(b) = max( f(a), g(b) )
重复执行(2)直到过程收敛。
重复过程中，若 f(a) 或 g(b)大于 2n，则表明该优先关系表不存在对应的优先函数。
```

**Bell 有向图法**

```
对于每个终结符 a（包括#）令其对应两个符号 fa 和ga，画一张以所有符号 fa 和 ga 为节点的方向图：
如果 a •> b 或 a =• b，则从 fa画一箭弧至 gb；
如果 a <• b 或 a =• b，则从 gb画一箭弧至 fa；
对每个节点赋一个值，该数等于从该节点出发所能达到节点（包括出发节点自身在内）的个数。
检查所构造出来的函数 f 和 g 与原优先关系表是否矛盾。
若无矛盾，则所求即为优先函数；
反之，则不存在优先函数。
```

## LR分析法

一个 LR 分析器由 3 个部分组成：

(1) 总控程序：对所有的 LR 分析器总控程序都是相同的。

(2) 分析表：不同的文法分析表将不同，分析表将也不同；

(3) 分析栈：文法符号栈和相应的状态栈，存放“历史”和“展望”信息。

**分析表**

LR 分析的核心部分是一张分析表(ACTION+GOTO)，为二维表结构。

GOTO[Si, X] 规定了状态 Si 面临文法符号 X∈VN∪VT 时，应转移到的下一状态。
ACTION[Sj, a] 规定了当状态 Sj (行标)面临输入符号 a(列标)时应执行的动作。有移进、归约、接受和报错四种动作。

* 移进：把状态 Sj=GOTO[Si,a]和输入符号 a 移入分析栈。
* 规约：当栈顶符号串 a 形成句柄，且文法中 A→a 的规则，其中 |a| = n，则规约动作是从分析栈顶去掉 n 个文法符号和 n 个状态，并把规约符 A 和 GOTO[Si-n,A]=Sj 移入分析栈中。
* 接受(acc)：表示分析成功。此时，分析栈中只剩下文法开始符号 S’ 和当前读到的输入符号 #。即输入符号串已经结束。
* 报错：表示输入串含有错误，此时出现在栈顶的状态遇到了不该遇到的输入符号。

**总控程序**

LR 分析器的总控程序工作的每一步只需按栈顶状态（行标）s 及当前输入（列标）a 执行 ACTION[s,a] 规定的动作：移进、归约、接受和报错。
对任何分析表，总控程序都是一样的。

### LR(0)分析法

LR 文法：
   对于一个文法，如果能构造一张 LR 分析表，使得它的每个入口均是唯一确定的，则把这个文法称为 LR 文法。
  一个文法，如果能用一个每步顶多向前检查 k 个输入符号的 LR 分析器进行分析，则把这个文法称为 LR(k) 文法。

LR 分析器的关键部分是分析表的构造

**文法规范句型的活前缀**

字符串的前缀是指字符串的任意首部。如 abc 的前缀有 a、ab、abc。
所谓活前缀是指规范句型的一个前缀，这种前缀不包含句柄之后的任何符号。

```
1	S→aAcBe
2	A→b
3	A→Ab
4	B→d
文法G[S]的每条产生式编上序号用[i]表示加在产生式的尾部，使产生式变为：
S→aAcBe[1]
A→b[2]
A→Ab[3]
B→d[4]
但[i]不属产生式的文法符号
```

<img src="https://i.loli.net/2020/05/06/j7Hgi6FhSvGse4I.png" alt="image.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/05/06/WhIkpw7OKDgbzQZ.png" alt="image.png" style="zoom:50%;" />

**文法的拓广**

若原文法 G 的开始符号为 S，在 G 中加产生式 S’→S 后得新的文法 G′，则称 G′为原文法 G 的拓广文法，而S′为拓广后文法 G′的开始符号。

```
G[S]:	S→(S)   S→a
G’[S’]:S’→S	S→(S)   S→a
```

**LR(0)项目**

活前缀中已经包含句柄的全部符号。此时意味着某一产生式 A的右部符号串  已经出现在栈顶，相应的分析动作应该是按该产生式归约。
活前缀中只包含句柄的一部分。此时意味着形如 A12 产生式的右部子串 1 已经出现在栈顶，正期待着从剩余的输入串中能移进或归约得2。
活前缀中不包含句柄的任何符号。此时意味着期待从剩余的输入串中能移进或归约得到某产生式 A 的右部 。

a) 移进和归约项目同时存在：　　形如：A→α·aβ　　　　　B→γ·　　由于这时面临输入符号为 a 时不能确定移进 a 还是把γ归约为 B，因为LR(0)分析是不向前看符号，所以对归约的项目不管当前符号是什么都应归约。对于在一个项目集中同时存在移进和归约项目时称该状态含有移进-归约冲突。b) 归约和归约项目同时存在。　　形如：A→β·　　　　　B→γ·　　因这时不管面临什么输入符号都不能确定归约为 A，还是归约为 B，对于在一个项目集中同时存在两个以上归约项目时称该状态含有归约-归约冲突。