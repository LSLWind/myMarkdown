### 服务器启动与查询过程

***服务器启动***

**mysqld**

`mysqld`这个可执行文件就代表着`MySQL`服务器程序，运行这个可执行文件就可以直接启动一个服务器进程。但这个命令不常用。

**mysqld_safe**

`mysqld_safe`是一个启动脚本，它会间接的调用`mysqld`，而且还顺便启动了另外一个监控进程，这个监控进程在服务器进程挂了的时候，可以帮助重启它。另外，使用`mysqld_safe`启动服务器程序时，它会将服务器程序的出错信息和其他诊断信息重定向到某个文件中，产生出错日志，这样可以方便我们找出发生错误的原因。

**mysql.server**

`mysql.server`也是一个启动脚本，它会间接的调用`mysqld_safe`，在调用`mysql.server`时在后边指定`start`参数就可以启动服务器程序了，就像这样：

```
mysql.server start
```

**mysqld_multi**

一台计算机上也可以运行多个服务器实例，也就是运行多个`MySQL`服务器进程。`mysql_multi`可执行文件可以对每一个服务器进程的启动或停止进行监控。

***启动MySQL客户端程序***

成功启动`MySQL`服务器程序后，就可以接着启动客户端程序来连接到这个服务器，`bin`目录下有许多客户端程序，比如`mysqladmin`、`mysqldump`、`mysqlcheck`等等。这里我们重点要关注的是可执行文件`mysql`，通过这个可执行文件可以让我们和服务器程序进程交互，也就是发送请求，接收服务器的处理结果。启动这个可执行文件时一般需要一些参数，格式如下：

```
mysql -h主机名  -u用户名 -p密码
```

各个参数的意义如下：

| 参数名 | 含义                                                         |
| :----: | :----------------------------------------------------------- |
|  `-h`  | 表示服务器进程所在计算机的域名或者IP地址，如果服务器进程就运行在本机的话，可以省略这个参数，或者填`localhost`或者`127.0.0.1`。也可以写作 `--host=主机名`的形式。 |
|  `-u`  | 表示用户名。也可以写作 `--user=用户名`的形式。               |
|  `-p`  | 表示密码。也可以写作 `--password=密码`的形式。               |

***查询过程***

 ![image_1c8d26fmg1af0ms81cpc7gm8lv39.png-97.9kB](https://user-gold-cdn.xitu.io/2018/12/28/167f4c7b99f87e1c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

查询缓存就不说了，缓存未命中时进行实际查询

虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。

**语法解析**

如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以`MySQL`服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到`MySQL`服务器内部使用的一些数据结构上来。

**查询优化**

语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，因为我们写的`MySQL`语句执行起来效率可能并不是很高，`MySQL`的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接等。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。我们可以使用`EXPLAIN`语句来查看某个语句的执行计划

### 存储引擎

截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，`MySQL`服务器把数据的存储和提取操作都封装到了一个叫`存储引擎`的模块里。我们知道`表`是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是`存储引擎`负责的事情。为了实现不同的功能，`MySQL`提供了各式各样的`存储引擎`，不同`存储引擎`管理的表具体的存储结构可能不同，采用的存取算法也可能不同。

为了管理方便，人们把`连接管理`、`查询缓存`、`语法解析`、`查询优化`这些并不涉及真实数据存储的功能划分为`MySQL server`的功能，把真实存取数据的功能划分为`存储引擎`的功能。各种不同的存储引擎向上边的`MySQL server`层提供统一的调用接口（也就是存储引擎API），包含了几十个底层函数，像"读取索引第一条内容"、"读取索引下一条内容"、"插入记录"等等。

所以在`MySQL server`完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。

***设置表的存储引擎***

我们前边说过，存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为不同的表设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。

我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎`InnoDB`。如果我们想显式的指定一下表的存储引擎，那可以这么写：

```
CREATE TABLE 表名(
    建表语句;
) ENGINE = 存储引擎名称;
```

比如我们想创建一个存储引擎为`MyISAM`的表可以这么写：

```
mysql> CREATE TABLE engine_demo_table(
    ->     i int
    -> ) ENGINE = MyISAM;
Query OK, 0 rows affected (0.02 sec)

mysql>
```

如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎：

```
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```

### 字符集

`utf8`字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在`MySQL`中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，在MySQL中自定义了两个概念：

- `utf8mb3`：阉割过的`utf8`字符集，只使用1～3个字节表示字符。

- `utf8mb4`：正宗的`utf8`字符集，使用1～4个字节表示字符。

有一点需要十分的注意，在`MySQL`中`utf8`是`utf8mb3`的别名，所以之后在`MySQL`中提到`utf8`就意味着使用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用`utf8mb4`。

在mysql中使用类型varchar(x)，x代表的是字符数量而不是字节

### 存储引擎InnoDB

InnoDB将磁盘中的数据以16KB为一页（块）进行划分作为数据传输单位，在逻辑上，以记录（行）为单位来向表中插入数据。对于Mysql来说，有四种不同的行格式，`Compact`、`Redundant`、`Dynamic`和`Compressed`

设置/修改行格式

```mysql
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

**Compact行格式**

[![loeuT0.md.png](https://s2.ax1x.com/2020/01/12/loeuT0.md.png)](https://imgchr.com/i/loeuT0)

记录的额外信息是<span style="color:red">服务器为了描述这条记录而不得不额外添加的一些信息</span>，这些额外信息分为3类

* 变长字段长度列表：MySQL支持变长数据类型，比如`VARCHAR(M)`、`VARBINARY(M)`、各种`TEXT`类型，各种`BLOB`类型，我们也可以把拥有这些数据类型的列称为`变长字段`，变长字段中存储多少字节的数据是不固定的，所以在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，即变长字段的存储=真实数据+占用字节数

在`Compact`行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序**逆序存放**

* NULL值列表：将每个允许存储`NULL`的列对应一个二进制位，二进制位按照列的顺序<span style="color:red">逆序</span>排列，1表示为NULL，0表示不为NULL，又因为以字节为单位，所以二进制位不够的高位补0
* 记录头信息：存储该记录在逻辑上的必要信息，如当前记录在堆中的位置，记录的类型，下一条记录的相对位置等
* 隐藏列：

|    列名     | 是否必须 | 占用空间 |          描述          |
| :---------: | :------: | :------: | :--------------------: |
|  DB_ROW_ID  |    否    | `6`字节  | 行ID，唯一标识一条记录 |
|  DB_TRX_ID  |    是    | `6`字节  |         事务ID         |
| DB_ROLL_PTR |    是    | `7`字节  |        回滚指针        |

事务ID与回滚指针是InnoDB默认自动添加的必要信息，隐藏行ID只有在必要时才自动生成。InnoDB对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique`键作为主键，如果表中连`Unique`键都没有定义的话，则`InnoDB`会为表默认添加一个名为DB_ROW_ID的隐藏列作为主键。



### 并发处理

#### select 显式加锁

```sql
SELECT ... LOCK IN SHARE MODE       #共享锁，其它事务可读，不可更新
SELECT ... FOR UPDATE               #排它锁，其它事务不可读写复制代码
```

#### update加锁机制

MySQL是支持给数据行加锁（InnoDB）的，并且在UPDATE/DELETE等操作时确实会自动加上排它锁。只是**并非只要有UPDATE关键字就会全程加锁**，针对上面的MySQL语句而言，其实并不只是一条UPDATE语句，而应该类似于两条SQL语句（伪代码）：

```sql
a = SELECT * FROM table1 WHERE id=1;
UPDATE table1 SET num = a.num + 1 WHERE id=1; 复制代码
```

其中执行SELECT语句时没有加锁，只有在执行UPDATE时才进行加锁的。所以才会出现并发操作时的更新数据不一致。

#### auto_increment原理

自增字段必须建立索引，可以不是主键索引，通过内部维护一个整形保证并发情况下该字段的唯一性。

auto_increment有三种模式：

1. innodb_autoinc_lock_mode=0（traditional lock mode） 传统模式：

每次插入列时对整个表加上AUTO_INC锁（表级锁），正常情况下连续（事务rollback可能出现间隙）

2. innodb_autoinc_lock_mode=1（consecutive lock mode） 

针对bulk inserts才会采用AUTO-INC锁这种方式，而针对simple inserts，则采用了一种新的轻量级的互斥锁来分配auto_increment列的值。当然，如果其他事务已经持有了AUTO-INC锁，则simple inserts需要等待

simple inserts指的是那种能够事先确定插入行数的语句，比如INSERT/REPLACE INTO 等插入单行或者多行的语句，语句中不包括嵌套子查询。此外，INSERT INTO … ON DUPLICATE KEY UPDATE这类语句也要除外。

bulk inserts指的是事先无法确定插入行数的语句，比如INSERT/REPLACE INTO … SELECT, LOAD DATA等。

mixed-mode inserts指的是simple inserts类型中有些行指定了auto_increment列的值有些没有指定，比如：
INSERT INTO t1 (c1,c2) VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’);
另外一种mixed-mode inserts是 INSERT … ON DUPLICATE KEY UPDATE这种语句，可能导致分配的auto_increment值没有被使用。

3.innodb_autoinc_lock_mode=2（interleaved lock mode）

这种模式下任何类型的inserts都不会采用AUTO-INC锁，性能最好，但是在同一条语句内部产生auto_increment值间隙。此外，这种模式对statement-based replication也不安全。

https://blog.csdn.net/sgbfblog/article/details/44536941