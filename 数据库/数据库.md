### 索引

一种数据结构，目的是加快检索数据库中的数据，如果不建索引要查询某个数据必须访问磁盘，以块为单位将数据加载至内存进行检验，IO时间很长。实现索引有很多种方式，如hash表，B+树等。

MySQL中索引属于存储引擎的概念，不同引擎对索引的实现方式不尽相同，MySql中主要有InnoDB与MyISAM，都使用B+树。

hash索引无法使用范围查询，没办法用索引完成排序，对于大量重复键值效率很低，因此B+树应用范围更广

索引最后仍针对sql语句做where的范围检查，对于表中的每个字段建立索引，查找时可根据索引快速查找，降低IO

 一张表可以建立**任意多个索引，**每个索引可以是**任意多个字段**的组合。索引**可能会提高查询速度**（如果查询时使用了索引），但**一定会减慢写入速度**，因为每次写入时都需要更新索引，所以索引只应该加在经常需要搜索的列上，不要加在写多读少的列上。 

#### 聚簇索引/非聚簇索引

聚簇索引的叶子节点就是数据节点，存储key值与整行数据，InnoDB中主键索引就是聚簇索引

非聚簇索引即叶子节点是索引节点，记录聚簇索引的key，查找时先查找到key，在根据这个key查找实际数据，即回表

非聚簇索引并不一定会导致回表，如果查询语句中的字段全部命中索引则不必进行回表查询

 ![img](https://pic4.zhimg.com/v2-8e9b0b297cf01d68b7a6ccd7a14a67d3_b.jpg) 

#### 覆盖索引

  覆盖索引指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。查询优化的一种常用手段，即建立特定字段的联合索引，查询时能全部命中，不必回表

#### 联合索引/最左前缀匹配原则

联合索引即对多个字段同时建立一个索引，想要命中索引必须按建立索引时的字段顺序严格使用

最左前缀匹配原则即最左优先，在检索数据时从联合索引的最左边开始匹配，示例：
对列col1、列col2和列col3建一个联合索引

```
KEY test_col1_col2_col3 on test(col1,col2,col3);
```

联合索引 test_col1_col2_col3 实际建立了(col1)、(col1,col2)、(col,col2,col3)三个索引。

```
SELECT * FROM test WHERE col1=“1” AND clo2=“2” AND clo4=“4”
```

上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。

### 事务

 事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。 

#### ACID

事务的ACID特性，即

* 原子性：事务操作要么全部成功，要么全部不成功
* 一致性： 数据库总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态.
*  隔离性: 一个事务在完全提交之前,对其他事务是不可见的 
*  持久性：一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果.

执行并发事务时可能出现以下几种情况：

#### 脏读

 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。 

| 时间点 | 事务A                       | 事务B                          |
| ------ | --------------------------- | ------------------------------ |
| T1     |                             | **开始事务**                   |
| T2     | **开始事务**                |                                |
| T3     |                             | 查询账户余额为1000元           |
| T4     |                             | 取出500元把余额改为500元       |
| T5     | 查询账户余额为500元（脏读） |                                |
| T6     |                             | **撤销事务**，余额恢复为1000元 |
| T7     | 存入100元把余额改为600元    |                                |
| T8     | **提交事务**                |                                |

#### 不可重复读

 是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。 强调数据的更新

| 时间点 | 事务A                                                 | 事务B                    |
| ------ | ----------------------------------------------------- | ------------------------ |
| T1     |                                                       | **开始事务**             |
| T2     | **开始事务**                                          |                          |
| T3     |                                                       | 查询账户余额为1000元     |
| T4     | 查询账户余额为1000元                                  |                          |
| T5     |                                                       | 取出100元把余额改为900元 |
| T6     |                                                       | **提交事务**             |
| T7     | 查询账户余额为900元（与T4读取的一不一致，不可重复读） |                          |

#### 幻读

读到已提交插入数据，幻读与不可重复读类似，幻读是查询到了另一个事务已提交的新插入数据，而不可重复读是查询到了另一个事务已提交的更新数据。通常发生在二次校验时发现了不一致数据，两次结果不一样，好像出现了幻觉。强调数据的插入与删除导致数据结果前后不一致

| 时间点 | 事务A                                                     | 事务B                          |
| ------ | --------------------------------------------------------- | ------------------------------ |
| T1     |                                                           | **开始事务**                   |
| T2     | **开始事务**                                              |                                |
| T3     | 统计用户Z总存款数为1000元                                 |                                |
| T4     |                                                           | 新增Z的一个存款账号，存款100元 |
| T5     |                                                           | **提交事务**                   |
| T6     |                                                           |                                |
| T7     | 再次统计用户Z总存款数为1100元（与T4读取的一不一致，幻读） |                                |

#### 数据库隔离级别

##### 读未提交

允许读取未提交数据，可能导致上述三种问题

##### 读已提交

只允许读取已提交数据（其它事务期间可修改数据并提交，因此可能导致不可重复读/幻读）

##### 可重复读

只允许读取已提交数据，并且在一个事务两次读取一个数据项期间，其它事务不能更新该数据。（但可以插入/删除数据，因此可能导致幻读）

##### 串行化

保证事务顺序执行

|                  | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| Read uncommitted | √    | √          | √    |
| Read committed   | ×    | √          | √    |
| Repeatable read  | ×    | ×          | √    |
| Serializable     | ×    | ×          | ×    |

 InnoDB默认使用的是可重复读隔离级别. 

### 锁

锁是一种机制，保证并发访问数据的一致性

#### 共享锁（S Lock）

读锁，可以有多个事务读，但一次只能有一个事务写

#### 排他锁（X Lock）

写锁，一次只能有一个事务对数据进行操作

#### 粒度锁

MySql中支持几种更细化的上锁方式，每种锁同时也分共享锁与排他锁：

**表锁**

对整张表进行上锁，开销小，加锁块，并发度低，一次性获取所有表的锁（按顺序给表加锁），一次不会出现死锁

**行锁**

对每行数据加锁，开销大，加锁慢，逐步获取数据，会出现死锁

**页锁**

介于表锁与行锁之间

#### 意向锁

InnoDB支持行级别的锁，假如表中有1亿数据，事务A使用共享锁锁了其中的几行，事务B想要对整张表加排它锁，因此必须扫描整个表，判断行数据是否加锁，开销过大，因此以引入意向锁的概念

- 意向共享锁（IS Lock）事务想要获得一张表中某几行的共享锁
- 意向排他锁（IX Lock）事务想要获得一张表中某几行的排他锁

即意向锁是整个表是否被上锁的标志，解决行锁与表锁之间的矛盾，事务先加上意向锁，表示整个表中有行已被加锁，其它想对整个表进行加锁的事务不必扫描整个表，阻塞等待即可

####  多版本并发控制 MVCC 

行级锁的一个变种， 通过保存数据在某个时间节点的快照(snapshot)，类似实现了行级锁。由此不同事务对同一表，同一时刻看到的数据可能是不一样的。 实现上通过在不同的数据行后增加创建日期版本号和删除日期版本号，且版本号不断递增，进而实现了数据快照 

#### 加锁处理分析

对于不同的sql语句，加锁情况是不同的，最终会根据情况加行锁或加表锁，如查询id是否为主键，当前数据库隔离级别，索引等

### Mysql存储引擎

 存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）。
  在Oracle 和SQL Server等数据库中只有一种存储引擎，所有数据存储管理机制都是一样的。而MySql数据库提供了多种存储引擎。用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据自己的需要编写自己的存储引擎。 