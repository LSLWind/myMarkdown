#### 刷题术语

##### 字母异或词

字母相同但顺序不同的两个单词

### 前缀树(字典树)

通常使用前缀树存储，快速查询单词，前缀树中，每个节点有一个char，表示一个字符，一个boolean表示到当前节点是否为关键字单词，一个List<Node>children表示下一层子节点，必须有根节点且根节点为' '，涉及到字典问题通常都需要用字典树来解决

```java
    class Node{
        char c;
        boolean end;//是否是关键字
        List<Node> next=new ArrayList<>();
        public Node(char c){
            this.c=c;
        }
    }
```

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/250px-Trie_example.svg.png" alt="img" style="zoom:150%;" />

使用前缀树可插入单词（关键字），查询所有前缀单词，查询具体单词

#### 初始化

```java
Node root=new Node(' ');//根节点,为' '
```
#### 插入单词

```java
public void insert(String word) {
        Node pre=root;//上一个节点
        List<Node>s=root.next;//当前层，即上一个节点的子节点
        
        for(int i=0;i<word.length();i++){
            boolean find=false;
            for(Node node:s){//遍历当前层，查找是否有相同字符
                if(node.c==word.charAt(i)){//有相同字符则可以进入下一层寻找
                    find=true;
                    pre=node;
                    s=node.next;//进入下一层
                    break;
                }
            }
            //没有发现字符，开辟剩下的路径
            if(!find){
                for(int j=i;j<word.length();j++){
                    Node tmp=new Node(word.charAt(j));
                    pre.next.add(tmp);
                    pre=tmp;
                }
                break;
            }
        }
        pre.end=true;//关键字标识表示到当前节点为关键字
    }
```

#### 查找单词

```java
public boolean search(String word) {
    Node pre=root;//上一个节点
    List<Node>s=root.next;//当前层，即上一个节点的子节点
    for(char c:word.toCharArray()){//遍历单词查找树
        boolean find=false;
        for(Node node:s){
            if(node.c==c){//查找到，进入下一层
                find=true;
                pre=node;
                s=node.next;
                break;
            }
        }
        if(!find)return false;//没有发现单词
    }
    
    return pre.end;//pre是最后一个节点，使用标识符判断其是否是关键字
}
```
#### 查找前缀单词

```java
public boolean startsWith(String prefix) {
    //先迭代到前缀底部，之后bfs
    Node pre=root;
    List<Node>s=root.next;
    for(char c:prefix.toCharArray()){
        boolean find=false;
        for(Node node:s){
            if(node.c==c){
                find=true;
                pre=node;
                s=node.next;
                break;
            }
        }
        if(!find)return false;
    }
    if(pre.end)return true;//前缀本身是一个单词，自然返回true
    return check(s);//否则bfs递归查找是否有该前缀的单词
}
private boolean check(List<Node> s){
    for(Node node:s){
        if(node.end)return true;
        else if(check(node.next))return true;
    }
    return false;
}
```
#### 例题(leetcode212-单词搜索)

给定一个二维网格 **board** 和一个字典中的单词列表 **words**，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

**示例:**

```
输入: 
words = ["oath","pea","eat","rain"] and board =
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]

输出: ["eat","oath"]
```

**说明:**
你可以假设所有输入都由小写字母 `a-z` 组成。

**提示:**

- 你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？
- 如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。

很显然，要使用前缀树结构，先将字典words的所有单词构成字典树，然后递归回溯board，每次判断时先检查单词前缀，如果前缀不存在则停止回溯，相当于进行了剪枝

```java
public List<String> findWords(char[][] board, String[] words) {
    //根据字典words建立前缀树
    for(String word:words){
        insert(word);
    }
    //回溯法查询board，如果前缀不同则停止回溯
    
    Set<String>res=new HashSet<>();//去重
    //每个字符作为起始点进行回溯
    for(int i=0;i<board.length;i++){
        for(int j=0;j<board[0].length;j++){
            boolean isUse[][]=new boolean[board.length][board[0].length];
            isUse[i][j]=true;
            bt(board,isUse,"",res,i,j);
        }
    }
    
    return new ArrayList<>(res);
}
```
回溯函数为bt

```java
private void bt(char[][] board,boolean[][] isUse,String pre,Set<String>res,int i,int j){
    
    String tmp=pre+board[i][j];//要判断的字符串
    
    if(!startsWith(tmp))return ;//不存在前缀，返回，相当于剪枝
    if(search(tmp)){
        res.add(tmp);//存在单词，加入res
    }
    //存在前缀，后面的递归查询，四个方向
    if(0<=i-1&&!isUse[i-1][j]){
        isUse[i-1][j]=true;
        bt(board,isUse,tmp,res,i-1,j);
        isUse[i-1][j]=false;//回退
    }
    if(i+1<board.length&&!isUse[i+1][j]){
        isUse[i+1][j]=true;
        bt(board,isUse,tmp,res,i+1,j);
        isUse[i+1][j]=false;//回退
    }  
    if(0<=j-1&&!isUse[i][j-1]){
        isUse[i][j-1]=true;
        bt(board,isUse,tmp,res,i,j-1);
        isUse[i][j-1]=false;//回退
    }
    if(j+1<board[0].length&&!isUse[i][j+1]){
        isUse[i][j+1]=true;
        bt(board,isUse,tmp,res,i,j+1);
        isUse[i][j+1]=false;
    }        
}
```

### 二进制基本运算

* a&1得到当前位的值
* a^a=0,a^0=a

#### 位运算实现加法

对于单个值的二进制运算，可以使用^替代

1. 1 + 1 = 0
2. 1 + 0 = 1
3. 0 + 1 = 1
4. 0 + 0 = 0

1. 1 ^ 1 = 0
2. 1 ^ 0 = 1
3. 0 ^ 1 = 1
4. 0 ^ 0 = 0

推广而言，a^b是不进行进位的加法操作，但是需要进位，因此需要进位补偿

对于进位而言，每次最多进位一次，<<刚好可代表进位一次，转换为计算当前进位值，而&操作刚好可计算出当前进位值，只有有两个1时才向前进位，1&1=1,其它则为0，因此(a&b)<<1为进位补偿

a^b+(a&b)<<1即代表位运算加法操作，公式中仍有+，因此需循环迭代公式，直到进位补偿值变为0

```java
    public int getSum(int a, int b) {
        while(b!=0)
        {
            int tmp = (a&b)<<1;//进位补偿值
            a = a^b;//无进位加法
            b = tmp;//a+b变为a^b+进位补偿值              
        }
        return a;
    }
```

### 栈的灵活使用

#### 迭代后序遍历二叉树

使用栈模拟递归，同时附加标志状态位表示是否已经判断过该节点，具体的：每次迭代时先弹出栈顶，判断栈顶元素是否被使用过，用过则res.add(val)，没用过则标志其用过，在压入栈中，然后判断左右子树，压入栈中

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer>res=new ArrayList<>();
        Stack<Pair>s=new Stack<>();
        if(root==null)return res;
        
        s.push(new Pair(root));
        while(s.size()!=0){
            Pair pair=s.pop();//弹出使用者
            if(pair.isUse)res.add(pair.node.val);//已经使用过了，标志着不用左右试探
            else{
                pair.isUse=true;//标志已使用
                s.push(pair);//返回到栈中
                if(pair.node.right!=null)s.push(new Pair(pair.node.right));//右边后遍历
                if(pair.node.left!=null)s.push(new Pair(pair.node.left));
            }
        }
        
        return res;
    }
    class Pair{
        TreeNode node;
        boolean isUse;
        public Pair(TreeNode node){
            this.node=node;
        }
    }
}
```

### 动态规划

#### 戳气球dp[i\][j]=max(dp[i\][k]+dp[k\][j]+nums[i]\*nums[k]\*nums[j])

有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。

求所能获得硬币的最大数量。

```java
class Solution {
    public int maxCoins(int[] nums) {
        if(nums.length<=0)return 0;
        //dp[i][j]表示i,j之间的气球爆掉的最大值,i,j不爆，为边界1，可放心爆炸
        //按照最优解，爆掉的气球是有顺序的，i,j不爆
        //假设在i,j中，k是最后一个被爆掉的气球，因此要爆掉(i,k),(k,j)之间的气球，ik,kj不爆
        //按照最优解，要递归求解(i,k),(k,j)爆气球最大值，子段重新排列，因此
        //dp[i][j]=max(dp[i][k]+dp[k][j]+nums[i]*nums[k]*nums[j])
        //nums[i]*nums[k]*nums[j]是因为在子段的爆气球过程中，要左右两部分的积，即子段
        //最后一个爆掉的气球要使用后边要爆掉的气球的积（即边界,i，j）
        //在自底向上的过程中，因为边界已经设置为1，所有可以放心爆炸
        
        //设置边界为1
        int[] tmp=new int[nums.length+2];
        tmp[0]=1;
        tmp[nums.length+1]=1;
        for(int i=0;i<nums.length;i++){
            tmp[i+1]=nums[i];
        }
        
        
        int[][] dp=new int[tmp.length][tmp.length];
        
        for(int i=tmp.length-3;i>=0;i--){
            for(int j=i+2;j<tmp.length;j++){
                //自底向上，求dp[i][j]
               int max=Integer.MIN_VALUE;
                for(int k=i+1;k<j;k++){
                    //选取k值作为气球的戳破点
                    max=Math.max(max,dp[i][k]+dp[k][j]+tmp[i]*tmp[k]*tmp[j]);
                }
                //System.out.println(max);
                dp[i][j]=max;
            }
        }
        
        return dp[0][tmp.length-1];
    }

}
```

