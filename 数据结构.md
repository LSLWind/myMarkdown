#### 刷题术语

##### 字母异或词

字母相同但顺序不同的两个单词

### 前缀树(字典树)

通常使用前缀树存储，快速查询单词，前缀树中，每个节点有一个char，表示一个字符，一个boolean表示到当前节点是否为关键字单词，一个List<Node>children表示下一层子节点，必须有根节点且根节点为' '，涉及到字典问题通常都需要用字典树来解决

```java
    class Node{
        char c;
        boolean end;//是否是关键字
        List<Node> next=new ArrayList<>();
        public Node(char c){
            this.c=c;
        }
    }
```

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/250px-Trie_example.svg.png" alt="img" style="zoom:150%;" />

使用前缀树可插入单词（关键字），查询所有前缀单词，查询具体单词

#### 初始化

```java
Node root=new Node(' ');//根节点,为' '
```
#### 插入单词

```java
public void insert(String word) {
        Node pre=root;//上一个节点
        List<Node>s=root.next;//当前层，即上一个节点的子节点
        
        for(int i=0;i<word.length();i++){
            boolean find=false;
            for(Node node:s){//遍历当前层，查找是否有相同字符
                if(node.c==word.charAt(i)){//有相同字符则可以进入下一层寻找
                    find=true;
                    pre=node;
                    s=node.next;//进入下一层
                    break;
                }
            }
            //没有发现字符，开辟剩下的路径
            if(!find){
                for(int j=i;j<word.length();j++){
                    Node tmp=new Node(word.charAt(j));
                    pre.next.add(tmp);
                    pre=tmp;
                }
                break;
            }
        }
        pre.end=true;//关键字标识表示到当前节点为关键字
    }
```

#### 查找单词

```java
public boolean search(String word) {
    Node pre=root;//上一个节点
    List<Node>s=root.next;//当前层，即上一个节点的子节点
    for(char c:word.toCharArray()){//遍历单词查找树
        boolean find=false;
        for(Node node:s){
            if(node.c==c){//查找到，进入下一层
                find=true;
                pre=node;
                s=node.next;
                break;
            }
        }
        if(!find)return false;//没有发现单词
    }
    
    return pre.end;//pre是最后一个节点，使用标识符判断其是否是关键字
}
```
#### 查找前缀单词

```java
public boolean startsWith(String prefix) {
    //先迭代到前缀底部，之后bfs
    Node pre=root;
    List<Node>s=root.next;
    for(char c:prefix.toCharArray()){
        boolean find=false;
        for(Node node:s){
            if(node.c==c){
                find=true;
                pre=node;
                s=node.next;
                break;
            }
        }
        if(!find)return false;
    }
    if(pre.end)return true;//前缀本身是一个单词，自然返回true
    return check(s);//否则bfs递归查找是否有该前缀的单词
}
private boolean check(List<Node> s){
    for(Node node:s){
        if(node.end)return true;
        else if(check(node.next))return true;
    }
    return false;
}
```
#### 例题(leetcode212-单词搜索)

给定一个二维网格 **board** 和一个字典中的单词列表 **words**，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

**示例:**

```
输入: 
words = ["oath","pea","eat","rain"] and board =
[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]

输出: ["eat","oath"]
```

**说明:**
你可以假设所有输入都由小写字母 `a-z` 组成。

**提示:**

- 你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？
- 如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。

很显然，要使用前缀树结构，先将字典words的所有单词构成字典树，然后递归回溯board，每次判断时先检查单词前缀，如果前缀不存在则停止回溯，相当于进行了剪枝

```java
public List<String> findWords(char[][] board, String[] words) {
    //根据字典words建立前缀树
    for(String word:words){
        insert(word);
    }
    //回溯法查询board，如果前缀不同则停止回溯
    
    Set<String>res=new HashSet<>();//去重
    //每个字符作为起始点进行回溯
    for(int i=0;i<board.length;i++){
        for(int j=0;j<board[0].length;j++){
            boolean isUse[][]=new boolean[board.length][board[0].length];
            isUse[i][j]=true;
            bt(board,isUse,"",res,i,j);
        }
    }
    
    return new ArrayList<>(res);
}
```
回溯函数为bt

```java
private void bt(char[][] board,boolean[][] isUse,String pre,Set<String>res,int i,int j){
    
    String tmp=pre+board[i][j];//要判断的字符串
    
    if(!startsWith(tmp))return ;//不存在前缀，返回，相当于剪枝
    if(search(tmp)){
        res.add(tmp);//存在单词，加入res
    }
    //存在前缀，后面的递归查询，四个方向
    if(0<=i-1&&!isUse[i-1][j]){
        isUse[i-1][j]=true;
        bt(board,isUse,tmp,res,i-1,j);
        isUse[i-1][j]=false;//回退
    }
    if(i+1<board.length&&!isUse[i+1][j]){
        isUse[i+1][j]=true;
        bt(board,isUse,tmp,res,i+1,j);
        isUse[i+1][j]=false;//回退
    }  
    if(0<=j-1&&!isUse[i][j-1]){
        isUse[i][j-1]=true;
        bt(board,isUse,tmp,res,i,j-1);
        isUse[i][j-1]=false;//回退
    }
    if(j+1<board[0].length&&!isUse[i][j+1]){
        isUse[i][j+1]=true;
        bt(board,isUse,tmp,res,i,j+1);
        isUse[i][j+1]=false;
    }        
}
```

### 二进制基本运算

* a&1得到当前位的值
* a^a=0,a^0=a

#### 位运算实现加法

对于单个值的二进制运算，可以使用^替代

1. 1 + 1 = 0
2. 1 + 0 = 1
3. 0 + 1 = 1
4. 0 + 0 = 0

1. 1 ^ 1 = 0
2. 1 ^ 0 = 1
3. 0 ^ 1 = 1
4. 0 ^ 0 = 0

推广而言，a^b是不进行进位的加法操作，但是需要进位，因此需要进位补偿

对于进位而言，每次最多进位一次，<<刚好可代表进位一次，转换为计算当前进位值，而&操作刚好可计算出当前进位值，只有有两个1时才向前进位，1&1=1,其它则为0，因此(a&b)<<1为进位补偿

a^b+(a&b)<<1即代表位运算加法操作，公式中仍有+，因此需循环迭代公式，直到进位补偿值变为0

```java
    public int getSum(int a, int b) {
        while(b!=0)
        {
            int tmp = (a&b)<<1;//进位补偿值
            a = a^b;//无进位加法
            b = tmp;//a+b变为a^b+进位补偿值              
        }
        return a;
    }
```

