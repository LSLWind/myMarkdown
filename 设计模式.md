### UML

##### 关联关系(Association)

是类与类之间最常用的一种关系， 它是一种结构化关系，用于表示一类对象与另一类对象之间有联系。 

单线实箭头，可自关联

![](https://pic.superbed.cn/item/5dc400758e0e2e3ee95d8592.jpg)

关联关系中要表明对象间的关联关系，如是一对多还是一对一

![](https://pic.superbed.cn/item/5dc400d48e0e2e3ee95daa53.jpg)

##### 依赖关系(Dependency)

一种使用关系，例如类A的某个方法需要类B做参数，即要使用类B的方法，用虚线表示

![](https://pic.superbed.cn/item/5dc4027c8e0e2e3ee95e8da3.jpg)

##### 聚合关系(Aggregation)

表示一个整体与部分的关系，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立 存在。聚合关系用带空心菱形的直线表示。

![](https://pic.superbed.cn/item/5dc401468e0e2e3ee95e2453.jpg)

##### 组合关系(Composition)

也表示类之间整体和部分的关系， 但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之间具有同生共死的关系。 如必须传递某个构造器参数以初始化类，用实心菱形的直线表示。

![](https://ae01.alicdn.com/kf/Hc013f39ab3b84ba09594e62351ceef45F.jpg)

##### 泛化关系(Generalization)

就是继承关系，用带空心三角形的直线来表示。 

##### 实现关系(Realization)

接口与实现的关系，用带空心三角形的虚线来表示。 

## 设计模式

### 对象创建型模式

#### 工厂方法模式

产品对象通过公共接口实现功能，抽象工厂声明工厂方法由具体子类去实现，工厂的目的是为了返回产品，抽象工厂声明的方法要返回抽象产品，每一个具体产品都对应有一个具体工厂，具体工厂返回具体产品，利用多态的性质，全程使用接口对象声明即可。

模式结构 

• Product：抽象产品，产品对象的共同父类或接口

• ConcreteProduct：具体产品 ，实现了抽象产品接口

• Factory：抽象工厂，声明工厂方法，交给子类实现

• ConcreteFactory：具体工厂，实现抽象工厂中的工厂方法，返回一个具体产品类的实例

![image.png](https://ae01.alicdn.com/kf/Hbc20c40da15d496a9de7fcbe495783d0K.jpg)

利用多态的性质，将通用方法抽象出来放在接口中，调用时更加灵活

所有的具体工厂类都具有同一抽象父类。在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 

![](https://ae01.alicdn.com/kf/H2b83dff1f9c44debb29bf8f34201abd0e.jpg)

```java
public interface Log {
    void writeLog();
}
public class FileLog implements Log {
    @Override
    public void writeLog(){
        System.out.println("我是文件日志写入器");
    }
}
public class DataBaseLog implements Log {
    @Override
    public void writeLog(){
        System.out.println("我是数据库日志写入器");
    }
}
```

```java
public interface AbstractLogFactory {
    Log createLog();
}
public class FileLogFactory implements AbstractLogFactory{
    @Override
    public Log createLog(){
        return new FileLog();
    }
}
public class DataBaseLogFactory implements AbstractLogFactory {
    @Override
    public Log createLog(){
        return new DataBaseLog();
    }
}
```

```java
public class FactoryMethodPatternTest {
    public static void main(String[] args){
        AbstractLogFactory abstractLogFactory;

        abstractLogFactory=new FileLogFactory();
        abstractLogFactory.createLog().writeLog();

        abstractLogFactory=new DataBaseLogFactory();
        abstractLogFactory.createLog().writeLog();
    }
}
```

运行结果为：

```
我是文件日志写入器
我是数据库日志写入器
```

#### 抽象工厂模式

弥补工厂方法模式每一种产品都需要新增具体工厂的不足，抽象工厂中声明多种产品工厂方法，能为一个产品家族返回多种属于该家族的具体产品。

当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。

模式结构：

 • AbstractFactory：抽象工厂

 • ConcreteFactory：具体工厂

 • AbstractProduct：抽象产品 

• Product：具体产品 

同样利用多态性质，符合开闭原则

![](https://ae01.alicdn.com/kf/H5b43c33366ae4f4aa56487c0b1b2aee6L.jpg)

```java
public interface Connection {
    boolean connection(String url,int port,String password);
}
public class OracleConnection implements Connection{
    @Override
    public  boolean connection(String url,int port,String password){
        System.out.println("已连接:"+url+port);
        return true;
    }
}
public class MySqlConnection implements Connection{
    @Override
    public  boolean connection(String url,int port,String password){
        System.out.println("已连接:"+url+port);
        return true;
    }
}
```

```java
public interface Statement {
    boolean getStatement();
}
public class OracleStatement implements Statement {
    @Override
    public  boolean getStatement(){
        System.out.println("create Oracle Statement");
        return true;
    }
}
public class MySqlStatement implements Statement {
    public  boolean getStatement(){
        System.out.println("create MySql Statement");
        return true;
    }
}
```

```java
public interface AbstractFactory {
    Connection createConnection();
    Statement createStatement();
}
public class OracleFactory implements AbstractFactory{
    @Override
    public Connection createConnection(){
        return new OracleConnection();
    }
    @Override
    public Statement createStatement(){
        return new OracleStatement();
    }
}
public class MySqlFactory implements AbstractFactory {
    @Override
    public Connection createConnection(){
        return new MySqlConnection();
    }
    @Override
    public Statement createStatement(){
        return new MySqlStatement();
    }
}
```

同样使用多态的性质，如果使用工厂方法模式，那么就需要建造两个抽象工厂，四个具体工厂，因为两个抽象产品属于同一个产品家族，所以只使用一个抽象工厂，把生产工厂的方法放在一起即可。缺点是难以扩展抽象产品，因为必须属于同一产品族的产品才可以加入，为了达到单一职责原则，不能在抽象工厂中任意添加产品

#### 建造者模式

将部件和其组装过程分开，一步一步创建一个复杂的对象。即将一个复杂对象的构建与它的表示分离。

也可能存在多个基本部分对象，基本部分对象通过不同的组合可以构建不同的对象，用户使用不同的具体建造者即可得到不同的产品对象。

模式结构

• Director：指挥者 ，用于实际生产产品，内部有方法construct，规定一个产品的构造顺序（即如何构造），通过对基本对象的组合生成一个复杂产品，内部维护建造者Builder，通过construct按顺序建造产品

 • Builder：抽象建造者 ，规定建造所有基本对象的方法

• ConcreteBuilder：具体建造者，实现每部分的建造方法

 • Product：产品角色 

建造者模式的目的仍然是为了解耦，屏蔽某些复杂产品的实现，生成产品的组件由接口声明，由具体的建造者建造，由Director调用组件组合顺序生成产品，允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节。

```java
//产品及组件
public class Product {
    private ComponentA componentA;
    private ComponentB componentB;
    public Product(ComponentA componentA,ComponentB componentB){
        this.componentA=componentA;
        this.componentB=componentB;
    }
    @Override
    public String toString(){
        return "我是产品";
    }
}

public class ComponentA {
    @Override
    public String toString(){
        return "我是组件A";
    }
}

public class ComponentB {
    @Override
    public String toString(){
        return "我是组件B";
    }
}
```

```java
//建造者及实现
public interface Builder {
    ComponentA buildA();
    ComponentB buildB();
}
public class ConcreteBuilder implements Builder{
    @Override
    public ComponentA buildA(){
        System.out.println("创建组件A");
        return new ComponentA();
    }
    @Override
    public ComponentB buildB(){
        System.out.println("创建组件B");
        return new ComponentB();
    }
}
```

```java
//指挥者，规定产品组合顺序，调用建造者组装成产品并返回
public class Director {
    public static Product buildProduct(){
        Builder builder=new ConcreteBuilder();
        return new Product(builder.buildA(),builder.buildB());
    }
}
public class builderPatternTest {
    public static void main(String[] args){
        Product product=Director.buildProduct();
        System.out.println(product.toString());
    }
}
/*运行结果
创建组件A
创建组件B
我是产品
*/
```

#### 原型模式

对象创建型模式，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象

在原型模式结构中定义了一个抽象原型类，所有的Java类都继承 自java.lang.Object，而Object类提供一个clone()方法，可以将 一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。 能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了 clone()方法，Java编译器将抛出一个 CloneNotSupportedException异常。

浅克隆只克隆同一份对象的域的引用，深克隆开辟新的空间并赋值

java中的clone()是深克隆，但copy的内存中如果有引用变量，那么引用的仍然是同一块空间，如果想让引用变量引用的空间也克隆一份，那么最好重写clone()或者自己另写一个创建原型的方法

```java
import java.util.Properties;
public class PrototypePatternTest {
    public static void main(String[] args){
        Properties properties=new Properties();
        properties.put("a",new Properties());
        Properties propertiesClone=(Properties) properties.clone();

        System.out.println(properties==propertiesClone);
        System.out.println(properties.getClass()==propertiesClone.getClass());
        
        //clone的对象引用新的空间
        properties.put("b",2);
        System.out.println(propertiesClone.get("b"));
        
        //但是内部的引用变量仍然引用同一块空间
        ((Properties)properties.get("a")).put("b","2");
        System.out.println(((Properties)propertiesClone.get("a")).get("b"));
    }
}
/*结果为
false
true
null
2
*/
```

使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。 

#### 单例模式

单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

单例模式的要点有三个：一是某个类只能有一个实例； 二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。

模式结构 

• Singleton：单例 

单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。

* 单例类的构造函数为私有； 
*  提供一个自身的静态私有成员变量； 
*  提供一个公有的静态工厂方法。  

确保只有一个对象被实例化的关键在于将构造器私有化，这样外部无法使用new构建对象，也无法通过反射实例化对象，这样一种设计思想确保系统中只有一个实例，提供关键服务，但对于该实例来说内部封装的对象的操作在并发环境下仍要保持原子性，单例模式确保我只有我一个，最常用的便是提供序列化id，系统必须确保每次提供的是唯一id，因此采用单例模式+原子操作（静态方法+原子操作也可以）。

```java
public class Singleton {

    private static Singleton singleton=new Singleton();

    private static volatile long id;
    //单例模式，私有化构造器，避免其他类new该对象
    private Singleton(){

    }
    public static Singleton getSingleton() {
        return singleton;
    }

    public synchronized long getId(){
        return id++;
    }
}
```

```java
public class SingletonPatternTest {
    public static void main(String[] args){
        //错误，不能访问私有
        //Singleton singleton=new Singleton();
        /*通过反射实例化将抛出java.lang.IllegalAccessException异常
        try {
            Singleton singleton=Singleton.class.newInstance();
        }catch (Exception e){
            e.printStackTrace();
        }
        */
        Singleton singleton=Singleton.getSingleton();
        for(int i=0;i<10;i++){
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName()+"我的id:"+singleton.getId());
                }
            }).start();
        }

    }
}
```

### 结构型模式

结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构

#### 适配器模式

在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者 (Adaptee)，即被适配的类。适配器提供客户类需要的接口，适配器的实现就是把客户类的请求 转化为对适配者的相应接口的调用。适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。 

简单的说，需要实现一个接口，这个接口的功能已经有一个类实现，但这个类却不符合接口的规则，因此使用适配器Adapter包装适配者Adaptee（可以有多个Adaptee），调用Adaptee的方法进行二次封装到Adapter的方法中，使用者调用Adapter的方法，并不关心适配器如何实现，反正Adapter对外能够提供功能即可

**模式定义 ：适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。** 

**适配器的核心在于使用新的类实现旧接口，老接口不能轻易动，新的实现类不符合老接口的规则，因此使用适配器实现老接口，调用新类的方法，相当于对各种实现类进行统合，对外能够通过统一的旧接口提供功能。**

 ![img](https://pic3.zhimg.com/v2-820a6161f73f65043ea3a35901df11ae_b.jpg) 

Outlet提供电压，AC plug插不进去，使用Adapter进行中间转化，使用者可以利用多态使用AC plug返回一个Adapter，Adapter调用Outlet提供电压。

适配器模式有三种实现方式：

[![M3LtmV.md.png](https://s2.ax1x.com/2019/11/12/M3LtmV.md.png)](https://imgchr.com/i/M3LtmV)

 **类适配器**

Adapter继承功能类实现老接口，通过super调用方法

作者：加耀





## **类适配器模式**

类适配器模式是通过继承来实现适配功能的，代码如下：

我们先来定义一个源角色(即220V电压)

```text
/**
 * 类 名: AC220V
 * 描 述: TODO  源角色
 * 作 者: 黄加耀
 * 创 建: 2019/2/11 : 19:30
 * 邮 箱: huangjy19940202@gmail.com
 *
 * @author: jiaYao
 */
public class AC220V {
    /**
     * 获取220V电压
     *
     * @return
     */
    public int output220v() {
        int output220v = 220;
        return output220v;
    }

}
```



然后我们再来定义一个目标角色(即通过适配从而获取到的5V电压)，这个地方我们定义的是一个接口

```text
/**
 * 类 名: DC5V
 * 描 述: TODO 目标角色
 * 作 者: 黄加耀
 * 创 建: 2019/2/11 : 19:32
 * 邮 箱: huangjy19940202@gmail.com
 *
 * @author: jiaYao
 */
public interface DC5V {

    int dc5v();

}
```



然后，我们再来定义一个适配器，适配器的作用是将220V电压转换成为5V电压。我们看看适配器的代码

```text
/**
 * 类 名: Adapter
 * 描 述: TODO 适配器角色
 * 作 者: 黄加耀
 * 创 建: 2019/2/11 : 19:33
 * 邮 箱: huangjy19940202@gmail.com
 *
 * @author: jiaYao
 */
public class Adapter extends AC220V implements DC5V {

    @Override
    public int dc5v() {
        int output220v = output220v();
        return (output220v / 44);
    }
}
```



这里，我们的适配器，继承于源角色并且实现目标角色，这样通过实现目标角色中的方法调用源角色中的方法进行运算，从而达到适配的效果。我们编写一个测试类看看

```text
public class Test {
    /**
     * 基于类的适配器模式
     */
    @org.junit.Test
    public void test(){
        DC5V dc5V =  new Adapter();
        int dc5 = dc5V.dc5v();
        System.out.println("转换后的电压为：" + dc5 + " 伏...");
    }
}
```



从代码中我们可以看到，其实适配器做的主要工作就是为了让目标角色的API可以调用到源角色的API，适配器在中间做的是一个类似的中转作用，并且不影响源角色和目标角色原有的功能和逻辑。

由于java只支持单继承，所以这里我们的目标角色定义的是一个接口。下面我们再来看看对象适配器

------

## **对象适配器**

对象适配器是通过组合来实现适配器功能的，即适配器拥有源角色的实例，我们使用代码来看看：

此处源角色和目标角色两个类代码和上面是一样的，不另做介绍，我们看看适配器角色代码

```text
/**
 * 类 名: Adapter
 * 描 述: TODO 适配器角色
 * 作 者: 黄加耀
 * 创 建: 2019/2/11 : 19:33
 * 邮 箱: huangjy19940202@gmail.com
 *
 * @author: jiaYao
 */
public class Adapter implements DC5V {

    private AC220V ac220V;

    public Adapter(AC220V ac220V) {
        this.ac220V = ac220V;
    }

    @Override
    public int dc5v() {
        int output220v = ac220V.output220v();
        return (output220v / 44);
    }
}
```



如上代码所示，我们的适配器中有一个有参构造，参数为源角色对象实例，适配器中有源角色对象实例引用，通过对象的引用我们进行适配转换。我们编写一个测试类看看

```text
public class Test {
    /**
     * 基于对象的适配器模式
     */
    @org.junit.Test
    public void test(){
        DC5V dc5V =  new Adapter(new AC220V());
        int dc5 = dc5V.dc5v();
        System.out.println("输入的电压为：" + new AC220V().output220v() + " 伏...");
        System.out.println("转换后的电压为：" + dc5 + " 伏...");
    }
}
```



如上所示，我们的测试类中在创建适配器时，传入参数为源角色实例，然后通过适配器将其转换为目标角色的API。

------

## **接口适配器**

介绍完类适配器和对象适配器，我们再来看看接口适配器，接口适配器相对类适配器和对象适配器而言，接口适配器相对更加灵活，就好比手机适配器中的万能适配器，不管接入的是多少伏的电源，最终都能保证输出电源为5V。

我们直接上代码看看：

首先，我们先来定义一个抽象的电源，并且给予一个默认值为220V

```text
**
 * 类 名: ACV
 * 描 述: 抽象的电源
 * 作 者: 黄加耀
 * 创 建: 2019/2/11 : 20:26
 * 邮 箱: huangjy19940202@gmail.com
 *
 * @author: jiaYao
 */
public abstract class ACV {

    public  int output(){
        return 220;
    }

}
```



然后我们再来定义具体的220V的电源

```text
**
 * 类 名: AC220V
 * 描 述: TODO  源角色--具体的220V电源
 * 作 者: 黄加耀
 * 创 建: 2019/2/11 : 19:30
 * 邮 箱: huangjy19940202@gmail.com
 *
 * @author: jiaYao
 */
public class AC220V extends ACV {
   
    @Override
    public int output() {
        return 220;
    }
}
```



我们再定义一个具体的110V电源，和220V电源一样，继承于抽象的电源类

```text
/**
 * 类 名: AC110V
 * 描 述:
 * 作 者: 黄加耀
 * 创 建: 2019/2/11 : 20:30
 * 邮 箱: huangjy19940202@gmail.com
 *
 * @author: jiaYao
 */
public class AC110V extends ACV {

    @Override
    public int output() {
        return 110;
    }
}
```



这样我们定义好了源角色，我们再来定义目标角色

```text
/**
 * 类 名: DC5V
 * 描 述: TODO 目标角色
 * 作 者: 黄加耀
 * 创 建: 2019/2/11 : 19:32
 * 邮 箱: huangjy19940202@gmail.com
 *
 * @author: jiaYao
 */
public interface DC5V {

    int dc5v();

}
```



目标角色还是一样，没有变化，我们再定义适配器角色看看

```text
/**
 * 类 名: Adapter
 * 描 述: TODO 适配器角色
 * 作 者: 黄加耀
 * 创 建: 2019/2/11 : 19:33
 * 邮 箱: huangjy19940202@gmail.com
 *
 * @author: jiaYao
 */
public class Adapter implements DC5V {

    private ACV acv;

    public Adapter(AC220V ac220V) {
        this.acv = ac220V;
    }

    public Adapter(AC110V ac110V) {
        this.acv = ac110V;
    }

    @Override
    public int dc5v() {
        int ac = 0;
        if (acv != null) {
            ac = acv.output();
        }
        int sta = ac / 5;
        return (ac / sta);
    }
}
```



如上代码，在适配器角色中，我们定义一个抽象的电源，并且提供多个适配器角色的有参构造，通过具体源角色的实例使用抽象的电源引用，适配器类实现于目标角色并实现目标角色的方法，在方法体中，我们进行逻辑处理，将输入的电压进行适配为5V电压，从而达到万能适配的效果。

这样，不管输入的电压为多少，都能做到有效适配为最终想要的结果。

我们再编写一个测试类看一下：

```text
public class Test {

    @org.junit.Test
    public void test() {
        DC5V dc5V = new Adapter(new AC220V());
        int dc = dc5V.dc5v();
        System.out.println("输入的电压为：" + new AC220V().output() + " 伏...");
        System.out.println("转换后的电压为：" + dc + " 伏...");
    }
}
```



在测试类中，我们提供具体的源角色，然后交由适配器进行适配。

如上就是适配器模式的三种适配形式，前两种适配器相对差别比较小，仅仅是在适配器阶段有所区别，但是接口适配器相对区别就比较大了。但是其目的都是一样的，就是将原本不匹配的两者变的匹配并且不影响原有的逻辑结构。

就像我们平时看到的转换器。

那么，我们在哪些场景中可以使用适配器呢？

比如，app中有一个登录接口，现在有一个新的需求，需要记录登录用户的ip信息，这个在原有的接口中并没有这个参数，所以就需要添加一个ip的参数字段。

但是，如果直接在接口上改动，这样之前的app就会出现不兼容的情况，这个时候，就可以使用适配器模式来解决这个问题了，实现新老代码兼容。