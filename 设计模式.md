### 设计模式

#### 工厂方法模式

产品对象通过公共接口实现功能，抽象工厂声明工厂方法由具体子类去实现，工厂的目的是为了返回产品，抽象工厂声明的方法要返回抽象产品，每一个具体产品都对应有一个具体工厂，具体工厂返回具体产品，利用多态的性质，全程使用接口对象声明即可。

模式结构 

• Product：抽象产品，产品对象的共同父类或接口

• ConcreteProduct：具体产品 ，实现了抽象产品接口

• Factory：抽象工厂，声明工厂方法，交给子类实现

• ConcreteFactory：具体工厂，实现抽象工厂中的工厂方法，返回一个具体产品类的实例

![image.png](https://ae01.alicdn.com/kf/Hbc20c40da15d496a9de7fcbe495783d0K.jpg)

利用多态的性质，将通用方法抽象出来放在接口中，调用时更加灵活

所有的具体工厂类都具有同一抽象父类。在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 

![](https://ae01.alicdn.com/kf/H2b83dff1f9c44debb29bf8f34201abd0e.jpg)

```java
public interface Log {
    void writeLog();
}
public class FileLog implements Log {
    @Override
    public void writeLog(){
        System.out.println("我是文件日志写入器");
    }
}
public class DataBaseLog implements Log {
    @Override
    public void writeLog(){
        System.out.println("我是数据库日志写入器");
    }
}
```

```java
public interface AbstractLogFactory {
    Log createLog();
}
public class FileLogFactory implements AbstractLogFactory{
    @Override
    public Log createLog(){
        return new FileLog();
    }
}
public class DataBaseLogFactory implements AbstractLogFactory {
    @Override
    public Log createLog(){
        return new DataBaseLog();
    }
}
```

```java
public class FactoryMethodPatternTest {
    public static void main(String[] args){
        AbstractLogFactory abstractLogFactory;

        abstractLogFactory=new FileLogFactory();
        abstractLogFactory.createLog().writeLog();

        abstractLogFactory=new DataBaseLogFactory();
        abstractLogFactory.createLog().writeLog();
    }
}
```

运行结果为：

```
我是文件日志写入器
我是数据库日志写入器
```

#### 抽象工厂模式

弥补工厂方法模式每一种产品都需要新增具体工厂的不足，抽象工厂中声明多种产品工厂方法，能为一个产品家族返回多种属于该家族的具体产品。

当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。

模式结构：

 • AbstractFactory：抽象工厂

 • ConcreteFactory：具体工厂

 • AbstractProduct：抽象产品 

• Product：具体产品 

同样利用多态性质，符合开闭原则

![](https://ae01.alicdn.com/kf/H5b43c33366ae4f4aa56487c0b1b2aee6L.jpg)

```java
public interface Connection {
    boolean connection(String url,int port,String password);
}
public class OracleConnection implements Connection{
    @Override
    public  boolean connection(String url,int port,String password){
        System.out.println("已连接:"+url+port);
        return true;
    }
}
public class MySqlConnection implements Connection{
    @Override
    public  boolean connection(String url,int port,String password){
        System.out.println("已连接:"+url+port);
        return true;
    }
}
```

```java
public interface Statement {
    boolean getStatement();
}
public class OracleStatement implements Statement {
    @Override
    public  boolean getStatement(){
        System.out.println("create Oracle Statement");
        return true;
    }
}
public class MySqlStatement implements Statement {
    public  boolean getStatement(){
        System.out.println("create MySql Statement");
        return true;
    }
}
```

```java
public interface AbstractFactory {
    Connection createConnection();
    Statement createStatement();
}
public class OracleFactory implements AbstractFactory{
    @Override
    public Connection createConnection(){
        return new OracleConnection();
    }
    @Override
    public Statement createStatement(){
        return new OracleStatement();
    }
}
public class MySqlFactory implements AbstractFactory {
    @Override
    public Connection createConnection(){
        return new MySqlConnection();
    }
    @Override
    public Statement createStatement(){
        return new MySqlStatement();
    }
}
```

同样使用多态的性质，如果使用工厂方法模式，那么就需要建造两个抽象工厂，四个具体工厂，因为两个抽象产品属于同一个产品家族，所以只使用一个抽象工厂，把生产工厂的方法放在一起即可。缺点是难以扩展抽象产品，因为必须属于同一产品族的产品才可以加入，为了达到单一职责原则，不能在抽象工厂中任意添加产品

#### 建造者模式

将部件和其组装过程分开，一步一步创建一个复杂的对象。即将一个复杂对象的构建与它的表示分离。

也可能存在多个基本部分对象，基本部分对象通过不同的组合可以构建不同的对象，用户使用不同的具体建造者即可得到不同的产品对象。

模式结构

• Director：指挥者 ，内部有方法construct，规定一个产品的构造顺序（即如何构造），通过对基本对象的组合生成一个复杂产品

 • Builder：抽象建造者 ，规定建造所有基本对象的方法

• ConcreteBuilder：具体建造者，实现每部分的建造方法

 • Product：产品角色 