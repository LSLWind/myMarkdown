为什么分用户态和核心态？

防止用户程序任意执行系统危险指令导致系统崩溃，保证操作系统对计算机资源的正确管理与程序的正确运行。

指令分为特权指令与非特权指令，对应的就是用户态与核心态，特权指令（如I/O，清内存）非常危险，不能允许用户随意使用。相当于操作系统对用户程序在权限与资源上的限制机制，这种机制是基于cpu提供的不同权限的运行状态来实现。 

内核态：当一个任务（进程）执行系统调用而陷入内核代码中执行时，就称进程处于内核运行态（或简称为内核态）。其他的属于用户态 。



系统调用和函数调用的区别？

* 函数调用在用户态运行，通过跳转指令完成；系统调用在管理态执行，通过中断机构来实现。

* 函数调用使用跳转指令，转向地址包含在跳转语句中；系统调用不包含处理程序入口，仅仅提供功能号，按功能号调用。
* 函数调用的调用程序与被调用代码在同一程序内，经过连接编译后作为目标代码的一部分；系统调用的处理代码在操作系统中，系统调用处理代码升级或修改时，与调用程序无关，一旦操作系统设计好，系统调用的功能、种类与数量就固定不变了。



内核态与用户态的区别？

* 用户态只能执行非特权指令；内核态可执行特权指令与非特权指令
* 用户态只能受限的访问内存；内核态可访问全部内存数据



CPU执行的是进程还是线程？

从调度方面来讲，线程是操作系统调度的基本单位，但严格来讲，CPU执行的只是指令。



如何创建进程和线程，进程和线程的底层实现？

针对Linux系统，使用fork()创建进程，线程可以通过第三方线程库创建，如LinuxThreads（pthread）

一个进程就是一个正在执行程序的实例，是操作系统分配资源的基本单位，由操作系统为每个程序创建进程、分配内存并进行进程之间的调度

一个进程至少会有一个线程，这个线程就是主线程，底层线程的实现有三种

* 内核线程：直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身。（一对一映射）
* 用户线程：用户自己编写，建立在自己的线程库上，用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。对一个进程而言，其所有的线程管理数据结构均在该进程自己的用户空间，管理线程切换的线程库也在用户地址空间运行。
* 混合线程：上述两者混合，线程的创建、调度、同步等在用户空间中完成，一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。



操作系统的进程调度策略？

* 先来先服务算法FCFS：谁先来就先服务谁，非剥夺
* 最短作业优先算法SJF：对每一个到来的作业进行时间估计，哪个时间最少就运行谁，非剥夺
* 最短剩余时间优先算法SRTF：对每一个到来的作业进行时间估计，对当前时刻的所有进程进行时间评估，时间少的可抢占CPU优先处理，剥夺式
* 响应比最高者优先算法HRRF：计算响应比，响应比 ＝ 作业的响应时间/作业处理时间，选择响应比最高的先执行，非剥夺
* 优先级调度算法：根据确定的优先级选取进程/线程，每次总是选择就绪队列中优先级最高者运行。
* 轮转调度算法：每次把CPU分配给就绪队列首进程/线程使用一个时间间隔（称为时间片），就绪队列中的每个进程/线程轮流运行一个时间片。



一个进程的内存空间具体是怎么分的？

在Linux中，会为每一个进程分配4GB的虚拟地址空间，其中包括

* 内核地址空间，使进程能与内核进行交互
* 栈：存放函数执行时的数据，如参数，局部变量等
* 堆：用户动态分配的内存空间，存放生命周期不固定的数据（用户动态分配的数据）
* 代码段：存放进程代码，也就是存放机器指令
* 数据段：存放全局数据、静态数据等



在操作系统里面的栈为什么要保证它后进先出？

进程运行时的数据是有生命周期的，如函数A调用了函数B，那么A中分配的数据a的空间应该比B中分配的数据b的空间更晚回收，为了保证内存正确的分配与回收，必须保证栈是后进先出



什么是内存泄露？

内存泄露指申请的内存空间没有正确释放导致后续程序无法使用这块内存，使得总内存空间越来越少

（内存溢出指储的数据超出了指定空间的大小导致溢出，造成数据的覆盖）



内存泄露的话程序上会有什么表现吗？

内存泄露导致可用内存空间越用越少，程序卡死，停止运行，或者抛出异常，严重的导致系统死机



如果我new了一个内存，然后在delete之前这个进程被系统杀死了。那这样是内存泄露吗？

不是，进程是操作系统分配资源的基本单位，从这个角度讲，进程被杀死后操作系统会收回其内存，不会导致泄漏。



Linux逻辑地址和物理地址的转换？

使用分页，逻辑地址=页号+业内偏移，物理地址=块号+块内偏移；由页号查页表找到物理块号就能确定物理地址

使用分段，逻辑地址=段号+段内位移，由段号查找进程段表，获取基址，物理地址=基址+段内位移



说说虚拟内存机制？

每个程序拥有自己的地址空间，将这块内存划分为多个块，每一块是一页，加载进程进入内存时只加载进程运行所必须的几个块（页/段），需要时再进行I/O，以提供给用户看起来多的内存空间。指令中的地址是虚拟内存地址，由页面映射为物理内存地址（页框）。



虚拟内存与物理内存的区别？

* 虚拟内存是逻辑上的，物理内存是实际的由总线位数确定的固定地址空间
* 每个程序拥有自己的地址空间，并且这个空间划分为多个页，与物理内存空间划分的页框进行映射
* 程序使用的是虚拟内存地址，在执行程序时，将其中的逻辑地址转变为物理地址（进行地址重定位）。



虚拟内存存在的意义？

虚拟内存将有限的内存空间扩充为逻辑上大得多的内存空间，每个程序拥有自己的地址空间，能运行给更多的程序、更大的程序。



操作系统分页？

使用虚拟内存，虚拟地址空间按照固定大小划分成称为页面（page）的若干单元，在物理内存中对应的单元称为页框（page frame）。



 操作系统快表？

快表使用缓冲的思想以加快速度，在存储管理部件中增设一个专用的高速缓冲存储器，用来存放最近访问过的部分页表项，这种高速缓冲存储器称为快表或联想存储器。引入快表的原因是CPU每存取一个指令/数据时，需要两次访问内存

有了快表，根据页号查找对应的物理块号时，首先查找快表中的局部页表，若找到则将物理块号和页内地址（也就是偏移地址）拼接形成物理地址，根据该物理地址访问相应的内存单元。若在快表中未找到物理块号，则再查找内存页表，获取物理块号一方面形成物理地址，另一方面将该表项抄到快表中，以备下次再次访问该页面时从快表中获得物理块号。查快表和查内存页表是同时进行的，一旦从快表中找到了对应项，则立即停止对内存页表的查找。



页面置换算法？

* 先进先出算法（FIFO）：先进先出页面淘汰算法总是淘汰最先调入主存的那一页，或者说在主存中驻留时间最长的那一页（常驻的除外）。

* 最近最久未使用页面淘汰算法（LRU）：淘汰的页面是在最近一段时间里较久未被访问的那一页。维护一个栈，每当命中时就将命中的页放到栈尾，每当缺页时就替换掉栈顶的页并将换进来的页放到栈尾
* 时钟页面替换算法

①页面首次装入主存时其“引用位”置1

②主存中的任何页面被访问时，“引用位”置1

③淘汰页面时，从指针当前指向的页面开始扫描循环队列，把遇到的“引用位”是1的页面的“引用位”清0，跳过这个页面；把所遇到的“引用位”是0的页面淘汰掉并换进来新的页，指针推进一步

④扫描完循环队列，若未淘汰任何页，则再次扫描





段描述符存在哪？

**GDT，全局描述符表**，全局描述符表会存放着所有的段描述符

段描述符=属性+基址+段界限














