## 数据结构

**B树与B+树的区别**

B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。

B+树中所有叶子节点都是通过指针连接在一起，而B树不会。

B+树的优点：

* 非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。
* 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。

B树的优点：

对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。

![](https://images2015.cnblogs.com/blog/576154/201609/576154-20160907130956629-1833512478.png)

## 算法

给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？**

使用位图（bitmap)，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。

**在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数**

采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。

**哈夫曼编码**

哈夫曼树是带权路径达到最小的二叉树，每个叶子节点都有权重，通过算法构造一颗权重越大越在上面的树，算法为：对所有节点按权重从小到大排序，先取两个最小的，使其权重和为一个新的节点，并将这两个节点作为新节点的左右子树，将新节点重新放入队列中，重复上述过程直至只有一棵树

按照该树进行编码可以获得最优的压缩