**给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？**

使用位图（bitmap)，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。

**在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数**

采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。

**哈夫曼编码**

哈夫曼树是带权路径达到最小的二叉树，每个叶子节点都有权重，通过算法构造一颗权重越大越在上面的树，算法为：对所有节点按权重从小到大排序，先取两个最小的，使其权重和为一个新的节点，并将这两个节点作为新节点的左右子树，将新节点重新放入队列中，重复上述过程直至只有一棵树

按照该树进行编码可以获得最优的压缩