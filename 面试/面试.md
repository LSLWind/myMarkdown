### java基础

#### java内存模型(JMM)

在多核CPU，多级缓存结构当中，每个核都有自己的缓存，这样在多线程环境下就可能存在**缓存一致性**问题，即每个线程对同一变量可能有不同的缓存结果。同时， 为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理 ，即进行**指令重排序**。

JMM在java虚拟机规范中被定义，用于屏蔽掉各种硬件和操作系统的内存访问差异， **保证Java程序在各种平台下对内存的访问都能保证效果一致。**

 Java内存模型规定：

1. 所有的变量都存储在主内存中（虚拟机内存的一部分），每条线程有自己的工作内存，线程的工作内存中保存使用到的变量的主内存副本拷贝
2. 线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。
3. 不同的线程之间无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。  

JMM底部提供基本原子操作规定内存交互操作细节并保证原子性，可见性，有序性

原子性：提供 两个高级的字节码指令`monitorenter`和`monitorexit` ，对应关键字为synchronized

可见性：提供关键字volatile，读取变量前从主内存刷新变量值并读取

有序性：synchronized与volatile都保证有序性，volatile禁止指令重排，synchronized保证同一时刻只允许一条线程操作。 

#### 集合Collections

##### Iterator

迭代器，一种设计模式，java.util中的一个接口，定义遍历序列元素的三个方法，可以遍历并选择序列中的对象

* boolean hasNext()
* E next()
* default void remove()

实现了Iterator就表示可迭代内部元素而无需知道底层细节，java.lang中还有一个Iterable接口，实现该接口表示可返回迭代器，定义方法(更像是一种解耦机制，将迭代元素与其他功能分开)：

* Iteratot<T\> iterator()

##### ArrayList

内部维护数组，支持随机访问

##### LinkedList

底层为双向链表，不支持随机访问

##### HashMap1.7/1.8

底部使用hash算法，维护hash表（数组/hash桶数组），使用链地址法解决冲突，内部维护变量

```java
 int threshold;             // 所能容纳的key-value对极限 
 final float loadFactor;    // 负载因子
 int modCount;  
 int size;
```

threshold=length*loadFactory，length为hash数组长度，也就是键值对数目由hash数组长度与负载因子决定,loadFactor常取0.75。即使用数值+单向链表

 在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数 ，因为分布情况由因数决定，冲突时进行取模运算，合数的因子比素数的因子多，因此对素数取模能使分布更加均匀。

put时取hashCode进行hash运算确定hash桶位置，有key则覆盖，没有则插入，插入成功判断容量，容量满则扩容，get同理，扩容时使用新数组覆盖旧数组与所有元素

jdk1.8进行了优化，当链表节点数量超过8是则使用红黑树进行替代（总数大于64），1.7在链表头部插入，1.8在尾部插入，线程不安全

### 网络

OSI:物理层→数据链路层→网络层→传输层→会话层→表示层→应用层

实际四层：物理层→网际层IP→传输层→应用层

#### TCP

面向连接(三次握手，四次挥手)，可靠传输（超时重传，返回确认机制）



#### UDP

无连接，不可靠传输

#### 常用HTTP状态码

* 2xx:成功
* 3xx：重定向
  * 301:永久性转移
  * 302:重定向

* 4xx：客户端错误
  * 400:服务器不理解语法
  * 401：未授权
  * 403：服务器拒绝请求
* 500：服务器内部错误
  * 503：服务不可用

#### cookie与session的区别

session是一种抽象概念，代表用户与服务器之间的唯一会话，实现时存储在后端，表现为保存用户信息的数据结构，session id用于标识唯一用户。

cookie是session的一种实现方式，cookie保存在浏览器，客户端发送请求时带上了cookie，cookie中携带session id，如果是第一次访问则浏览器会自动生成一个session id 交给服务器保存，服务器通过session id查找session对象，并能够直接拿出来使用。通过session也可以直接设置cookie发给浏览器保存，下次能读取想要的信息。

#### token

与sessionID功能相同，用于用户验证，不同的是token由特殊算法生成，加密后带签名，传过来时经过解密，如果签名与获得的签名相同则验证通过，直接拿id返回对应数据给用户，即服务器端不保存信息，只进行运算，以时间换空间

#### 用session实现验证码

1. 第一次请求表单页面时通过Servlet生成随机字符验证码并放在session（通过request获取session）中（即在session中设置一个验证码属性key-value），将验证码放在一张图片上绘制并返回
2. 提交表单时通过session获取验证码并与表单数据进行校验即可

### 数据库

#### 数据库隔离级别

**读未提交**

允许读取未提交数据，可能导致脏读、不可重复读、幻读

**读已提交**

只允许读取已提交数据（其它事务期间可修改数据并提交，因此可能导致不可重复读/幻读）

**可重复读**

只允许读取已提交数据，并且在一个事务两次读取一个数据项期间，其它事务不能更新该数据。（但可以插入/删除数据，因此可能导致幻读）

**串行化**

保证事务顺序执行

### 并发

#### 进程与线程

进程是程序运行与资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。

线程操作系统调度的最小单位，是进程的一个执行单元

#### 创建进程的几种方式

继承Thread，重写run()方法

实现接口Runnable()，实现run()方法，作为参数传递给Thread

实现接口Callable()，实现方法call()，交给线程池返回Future，或者使用FutureTask进行包装交给线程池执行或者传参给Thread(因为FutureTask也实现了Runnable接口)

Runnable与Callable的区别在于Runnable中的run是无返回值的，而Callable中的call有返回值，可配合Future与FutureTask获取异步执行结果

#### 线程状态

五态模型，创建、就绪、运行、阻塞、死亡

#### sleep()与wait()

sleep()是Thread的静态方法，让调用线程休眠，无法改变对象的锁机制

wait()是Object方法，有notify()与notifyAll()配合使用，调用wait()的线程陷入等待，释放锁，等待唤醒，notify()从等待池中随机唤醒一个，notifyAll()唤醒所有

#### 锁升级

检查对象头的Mark Word的ThreadID判断是否持有偏向锁，未持有检查使用对象的线程是否存活和是否仍需要使用对象，不需要则置对象为无锁状态，重新获取偏向锁，否则升级为轻量级锁，CAS自旋获取锁，CAS到一定次数仍未得到锁则升级为重量级锁

#### ThreadLocal

线程局部变量，线程私有，实现线程安全的一种方式

#### synchronized/volatile

synchronized保证原子性、可见性，底层基于指令monitorenter与monitorexit

volatile保证内存可见性，将变量刷新到内存中，每次使用从内存获取，避免缓存不一致，禁止指令重排序